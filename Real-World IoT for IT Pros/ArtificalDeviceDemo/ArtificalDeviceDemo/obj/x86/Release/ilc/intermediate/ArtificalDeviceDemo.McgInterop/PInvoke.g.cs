#define MCG_WINRT_SUPPORTED
using Mcg.System;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.WindowsRuntime;


// -----------------------------------------------------------------------------------------------------------
// 
// WARNING: THIS SOURCE FILE IS FOR 32-BIT BUILDS ONLY!
// 
// MCG GENERATED CODE
// 
// This C# source file is generated by MCG and is added into the application at compile time to support interop features.
// 
// It has three primary components:
// 
// 1. Public type definitions with interop implementation used by this application including WinRT & COM data structures and P/Invokes.
// 
// 2. The 'McgInterop' class containing marshaling code that acts as a bridge from managed code to native code.
// 
// 3. The 'McgNative' class containing marshaling code and native type definitions that call into native code and are called by native code.
// 
// -----------------------------------------------------------------------------------------------------------
// 
// warning CS0067: The event 'event' is never used
#pragma warning disable 67
// warning CS0169: The field 'field' is never used
#pragma warning disable 169
// warning CS0649: Field 'field' is never assigned to, and will always have its default value 0
#pragma warning disable 414
// warning CS0414: The private field 'field' is assigned but its value is never used
#pragma warning disable 649
// warning CS1591: Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// warning CS0108 'member1' hides inherited member 'member2'. Use the new keyword if hiding was intended.
#pragma warning disable 108
// warning CS0114 'member1' hides inherited member 'member2'.  To make the current method override that implementation, add the override keyword. Otherwise add the new keyword.
#pragma warning disable 114
// warning CS0659 'type' overrides Object.Equals but does not override GetHashCode.
#pragma warning disable 659
// warning CS0465 Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?
#pragma warning disable 465
// warning CS0028 'function declaration' has the wrong signature to be an entry point
#pragma warning disable 28
// warning CS0162 Unreachable code Detected
#pragma warning disable 162
// warning CS0628 new protected member declared in sealed class
#pragma warning disable 628

namespace McgInterop
{
	/// <summary>
	/// P/Invoke class for module 'kernel32.dll'
	/// </summary>
	public unsafe static partial class kernel32_dll
	{
		// Signature, GetCurrentProcessId, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("Microsoft.Azure.Amqp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", "Win32", "GetCurrentProcessId")]
		public static int GetCurrentProcessId()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.kernel32_dll_PInvokes.GetCurrentProcessId();
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'BCrypt'
	/// </summary>
	public unsafe static partial class BCrypt
	{
		// Signature, BCryptEnumAlgorithms, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_AlgorithmOperations__PInvoke_BCrypt__BCrypt_AlgorithmOperations__PInvoke_BCrypt, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] PInvoke_BCrypt_BCRYPT_ALGORITHM_IDENTIFIER__PInvoke_BCrypt___ptrPInvoke__BCrypt_BCRYPT_ALGORITHM_IDENTIFIER__PInvoke_BCrypt *, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptEnumAlgorithmsFlags__PInvoke_BCrypt__BCrypt_BCryptEnumAlgorithmsFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptEnumAlgorithms")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptEnumAlgorithms(
					global::PInvoke.BCrypt_AlgorithmOperations__PInvoke_BCrypt dwAlgOperations, 
					out int pAlgCount, 
					out global::PInvoke.BCrypt_BCRYPT_ALGORITHM_IDENTIFIER__PInvoke_BCrypt* ppAlgList, 
					global::PInvoke.BCrypt_BCryptEnumAlgorithmsFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			int unsafe_pAlgCount;
			global::PInvoke.BCrypt_BCRYPT_ALGORITHM_IDENTIFIER__PInvoke_BCrypt* unsafe_ppAlgList;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptEnumAlgorithms(
								dwAlgOperations, 
								&(unsafe_pAlgCount), 
								&(unsafe_ppAlgList), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			ppAlgList = (global::PInvoke.BCrypt_BCRYPT_ALGORITHM_IDENTIFIER__PInvoke_BCrypt*)unsafe_ppAlgList;
			pAlgCount = unsafe_pAlgCount;
			// Return
			return unsafe___value;
		}

		// Signature, BCryptOpenAlgorithmProvider, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptOpenAlgorithmProviderFlags__PInvoke_BCrypt__BCrypt_BCryptOpenAlgorithmProviderFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptOpenAlgorithmProvider")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptOpenAlgorithmProvider(
					out global::PInvoke.BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt phAlgorithm, 
					string pszAlgId, 
					string pszImplementation, 
					global::PInvoke.BCrypt_BCryptOpenAlgorithmProviderFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			global::System.IntPtr unsafe_phAlgorithm;
			ushort* unsafe_pszAlgId = default(ushort*);
			ushort* unsafe_pszImplementation = default(ushort*);
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			phAlgorithm = new global::PInvoke.BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt();
			unsafe_phAlgorithm = phAlgorithm.DangerousGetHandle();
			fixed (char* pinned_pszAlgId = pszAlgId)
			{
				unsafe_pszAlgId = (ushort*)pinned_pszAlgId;
				fixed (char* pinned_pszImplementation = pszImplementation)
				{
					unsafe_pszImplementation = (ushort*)pinned_pszImplementation;
					// Call to native method
					unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptOpenAlgorithmProvider(
										&(unsafe_phAlgorithm), 
										unsafe_pszAlgId, 
										unsafe_pszImplementation, 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phAlgorithm, 
								unsafe_phAlgorithm
							);
			// Return
			return unsafe___value;
		}

		// Signature, BCryptCreateHash, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeHashHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptCreateHashFlags__PInvoke_BCrypt__BCrypt_BCryptCreateHashFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptCreateHash")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptCreateHash(
					global::PInvoke.BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt hAlgorithm, 
					out global::PInvoke.BCrypt_SafeHashHandle__PInvoke_BCrypt phHash, 
					byte[] pbHashObject, 
					int cbHashObject, 
					byte[] pbSecret, 
					int cbSecret, 
					global::PInvoke.BCrypt_BCryptCreateHashFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_phHash;
			byte* unsafe_pbHashObject;
			byte* unsafe_pbSecret;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hAlgorithm.DangerousAddRef(ref addRefed);
			phHash = new global::PInvoke.BCrypt_SafeHashHandle__PInvoke_BCrypt();
			unsafe_phHash = phHash.DangerousGetHandle();
			fixed (byte* pinned_pbHashObject = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbHashObject))
			{
				unsafe_pbHashObject = (byte*)pinned_pbHashObject;
				fixed (byte* pinned_pbSecret = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbSecret))
				{
					unsafe_pbSecret = (byte*)pinned_pbSecret;
					// Call to native method
					unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptCreateHash(
										hAlgorithm.DangerousGetHandle(), 
										&(unsafe_phHash), 
										unsafe_pbHashObject, 
										cbHashObject, 
										unsafe_pbSecret, 
										cbSecret, 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phHash, 
								unsafe_phHash
							);
			if (addRefed)
				hAlgorithm.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptEncrypt, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptEncryptFlags__PInvoke_BCrypt__BCrypt_BCryptEncryptFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptEncrypt")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptEncrypt(
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt hKey, 
					byte* pbInput, 
					int cbInput, 
					void* pPaddingInfo, 
					byte* pbIV, 
					int cbIV, 
					byte* pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					global::PInvoke.BCrypt_BCryptEncryptFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe_pcbResult;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptEncrypt(
								hKey.DangerousGetHandle(), 
								((byte*)pbInput), 
								cbInput, 
								((void*)pPaddingInfo), 
								((byte*)pbIV), 
								cbIV, 
								((byte*)pbOutput), 
								cbOutput, 
								&(unsafe_pcbResult), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			pcbResult = unsafe_pcbResult;
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptDecrypt, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptEncryptFlags__PInvoke_BCrypt__BCrypt_BCryptEncryptFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptDecrypt")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptDecrypt(
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt hKey, 
					byte* pbInput, 
					int cbInput, 
					void* pPaddingInfo, 
					byte* pbIV, 
					int cbIV, 
					byte* pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					global::PInvoke.BCrypt_BCryptEncryptFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe_pcbResult;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptDecrypt(
								hKey.DangerousGetHandle(), 
								((byte*)pbInput), 
								cbInput, 
								((void*)pPaddingInfo), 
								((byte*)pbIV), 
								cbIV, 
								((byte*)pbOutput), 
								cbOutput, 
								&(unsafe_pcbResult), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			pcbResult = unsafe_pcbResult;
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptHashData, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeHashHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptHashDataFlags__PInvoke_BCrypt__BCrypt_BCryptHashDataFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptHashData")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptHashData(
					global::PInvoke.BCrypt_SafeHashHandle__PInvoke_BCrypt hHash, 
					byte[] pbInput, 
					int cbInput, 
					global::PInvoke.BCrypt_BCryptHashDataFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pbInput;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hHash.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pbInput = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbInput))
			{
				unsafe_pbInput = (byte*)pinned_pbInput;
				// Call to native method
				unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptHashData(
									hHash.DangerousGetHandle(), 
									unsafe_pbInput, 
									cbInput, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				hHash.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptFinishHash, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeHashHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptFinishHashFlags__PInvoke_BCrypt__BCrypt_BCryptFinishHashFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptFinishHash")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptFinishHash(
					global::PInvoke.BCrypt_SafeHashHandle__PInvoke_BCrypt hHash, 
					byte[] pbOutput, 
					int cbOutput, 
					global::PInvoke.BCrypt_BCryptFinishHashFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pbOutput;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hHash.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pbOutput = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbOutput))
			{
				unsafe_pbOutput = (byte*)pinned_pbOutput;
				// Call to native method
				unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptFinishHash(
									hHash.DangerousGetHandle(), 
									unsafe_pbOutput, 
									cbOutput, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				hHash.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptSignHash, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptSignHashFlags__PInvoke_BCrypt__BCrypt_BCryptSignHashFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptSignHash")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptSignHash(
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt hKey, 
					void* pPaddingInfo, 
					byte[] pbInput, 
					int cbInput, 
					byte[] pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					global::PInvoke.BCrypt_BCryptSignHashFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pbInput;
			byte* unsafe_pbOutput;
			int unsafe_pcbResult = 0;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pbInput = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbInput))
			{
				unsafe_pbInput = (byte*)pinned_pbInput;
				fixed (byte* pinned_pbOutput = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbOutput))
				{
					unsafe_pbOutput = (byte*)pinned_pbOutput;
					// Call to native method
					unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptSignHash(
										hKey.DangerousGetHandle(), 
										((void*)pPaddingInfo), 
										unsafe_pbInput, 
										cbInput, 
										unsafe_pbOutput, 
										cbOutput, 
										&(unsafe_pcbResult), 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					pcbResult = unsafe_pcbResult;
				}
			}
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptVerifySignature, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptSignHashFlags__PInvoke_BCrypt__BCrypt_BCryptSignHashFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptVerifySignature")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptVerifySignature(
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt hKey, 
					void* pPaddingInfo, 
					byte[] pbHash, 
					int cbHash, 
					byte[] pbSignature, 
					int cbSignature, 
					global::PInvoke.BCrypt_BCryptSignHashFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pbHash;
			byte* unsafe_pbSignature;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pbHash = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbHash))
			{
				unsafe_pbHash = (byte*)pinned_pbHash;
				fixed (byte* pinned_pbSignature = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbSignature))
				{
					unsafe_pbSignature = (byte*)pinned_pbSignature;
					// Call to native method
					unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptVerifySignature(
										hKey.DangerousGetHandle(), 
										((void*)pPaddingInfo), 
										unsafe_pbHash, 
										cbHash, 
										unsafe_pbSignature, 
										cbSignature, 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptGenerateKeyPair, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptGenerateKeyPairFlags__PInvoke_BCrypt__BCrypt_BCryptGenerateKeyPairFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptGenerateKeyPair")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptGenerateKeyPair(
					global::PInvoke.BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt hAlgorithm, 
					out global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt phKey, 
					int dwLength, 
					global::PInvoke.BCrypt_BCryptGenerateKeyPairFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_phKey;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hAlgorithm.DangerousAddRef(ref addRefed);
			phKey = new global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt();
			unsafe_phKey = phKey.DangerousGetHandle();
			// Call to native method
			unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptGenerateKeyPair(
								hAlgorithm.DangerousGetHandle(), 
								&(unsafe_phKey), 
								dwLength, 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phKey, 
								unsafe_phKey
							);
			if (addRefed)
				hAlgorithm.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptGenerateSymmetricKey, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptGenerateSymmetricKeyFlags__PInvoke_BCrypt__BCrypt_BCryptGenerateSymmetricKeyFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptGenerateSymmetricKey")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptGenerateSymmetricKey(
					global::PInvoke.BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt hAlgorithm, 
					out global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt phKey, 
					byte[] pbKeyObject, 
					int cbKeyObject, 
					byte[] pbSecret, 
					int cbSecret, 
					global::PInvoke.BCrypt_BCryptGenerateSymmetricKeyFlags__PInvoke_BCrypt flags)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_phKey;
			byte* unsafe_pbKeyObject;
			byte* unsafe_pbSecret;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hAlgorithm.DangerousAddRef(ref addRefed);
			phKey = new global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt();
			unsafe_phKey = phKey.DangerousGetHandle();
			fixed (byte* pinned_pbKeyObject = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbKeyObject))
			{
				unsafe_pbKeyObject = (byte*)pinned_pbKeyObject;
				fixed (byte* pinned_pbSecret = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbSecret))
				{
					unsafe_pbSecret = (byte*)pinned_pbSecret;
					// Call to native method
					unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptGenerateSymmetricKey(
										hAlgorithm.DangerousGetHandle(), 
										&(unsafe_phKey), 
										unsafe_pbKeyObject, 
										cbKeyObject, 
										unsafe_pbSecret, 
										cbSecret, 
										flags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phKey, 
								unsafe_phKey
							);
			if (addRefed)
				hAlgorithm.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptFinalizeKeyPair, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptFinalizeKeyPairFlags__PInvoke_BCrypt__BCrypt_BCryptFinalizeKeyPairFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptFinalizeKeyPair")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptFinalizeKeyPair(
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt hKey, 
					global::PInvoke.BCrypt_BCryptFinalizeKeyPairFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptFinalizeKeyPair(
								hKey.DangerousGetHandle(), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptImportKey, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptImportKeyFlags__PInvoke_BCrypt__BCrypt_BCryptImportKeyFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptImportKey")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptImportKey(
					global::PInvoke.BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt hAlgorithm, 
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt hImportKey, 
					string pszBlobType, 
					out global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt phKey, 
					byte[] pbKeyObject, 
					int cbKeyObject, 
					byte[] pbInput, 
					int cbInput, 
					global::PInvoke.BCrypt_BCryptImportKeyFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			ushort* unsafe_pszBlobType = default(ushort*);
			global::System.IntPtr unsafe_phKey;
			byte* unsafe_pbKeyObject;
			byte* unsafe_pbInput;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hAlgorithm.DangerousAddRef(ref addRefed);
			hImportKey.DangerousAddRef(ref addRefed_1);
			fixed (char* pinned_pszBlobType = pszBlobType)
			{
				unsafe_pszBlobType = (ushort*)pinned_pszBlobType;
				phKey = new global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt();
				unsafe_phKey = phKey.DangerousGetHandle();
				fixed (byte* pinned_pbKeyObject = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbKeyObject))
				{
					unsafe_pbKeyObject = (byte*)pinned_pbKeyObject;
					fixed (byte* pinned_pbInput = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbInput))
					{
						unsafe_pbInput = (byte*)pinned_pbInput;
						// Call to native method
						unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptImportKey(
											hAlgorithm.DangerousGetHandle(), 
											hImportKey.DangerousGetHandle(), 
											unsafe_pszBlobType, 
											&(unsafe_phKey), 
											unsafe_pbKeyObject, 
											cbKeyObject, 
											unsafe_pbInput, 
											cbInput, 
											dwFlags
										);
						global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
				}
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									phKey, 
									unsafe_phKey
								);
			}
			if (addRefed_1)
				hImportKey.DangerousRelease();
			if (addRefed)
				hAlgorithm.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptImportKeyPair, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptImportKeyPairFlags__PInvoke_BCrypt__BCrypt_BCryptImportKeyPairFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptImportKeyPair")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptImportKeyPair(
					global::PInvoke.BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt hAlgorithm, 
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt hImportKey, 
					string pszBlobType, 
					out global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt phKey, 
					byte[] pbInput, 
					int cbInput, 
					global::PInvoke.BCrypt_BCryptImportKeyPairFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			ushort* unsafe_pszBlobType = default(ushort*);
			global::System.IntPtr unsafe_phKey;
			byte* unsafe_pbInput;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hAlgorithm.DangerousAddRef(ref addRefed);
			hImportKey.DangerousAddRef(ref addRefed_1);
			fixed (char* pinned_pszBlobType = pszBlobType)
			{
				unsafe_pszBlobType = (ushort*)pinned_pszBlobType;
				phKey = new global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt();
				unsafe_phKey = phKey.DangerousGetHandle();
				fixed (byte* pinned_pbInput = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbInput))
				{
					unsafe_pbInput = (byte*)pinned_pbInput;
					// Call to native method
					unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptImportKeyPair(
										hAlgorithm.DangerousGetHandle(), 
										hImportKey.DangerousGetHandle(), 
										unsafe_pszBlobType, 
										&(unsafe_phKey), 
										unsafe_pbInput, 
										cbInput, 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									phKey, 
									unsafe_phKey
								);
			}
			if (addRefed_1)
				hImportKey.DangerousRelease();
			if (addRefed)
				hAlgorithm.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptExportKey, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptExportKeyFlags__PInvoke_BCrypt__BCrypt_BCryptExportKeyFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptExportKey")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptExportKey(
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt hKey, 
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt hExportKey, 
					string pszBlobType, 
					byte[] pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					global::PInvoke.BCrypt_BCryptExportKeyFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			ushort* unsafe_pszBlobType = default(ushort*);
			byte* unsafe_pbOutput;
			int unsafe_pcbResult = 0;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			hExportKey.DangerousAddRef(ref addRefed_1);
			fixed (char* pinned_pszBlobType = pszBlobType)
			{
				unsafe_pszBlobType = (ushort*)pinned_pszBlobType;
				fixed (byte* pinned_pbOutput = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbOutput))
				{
					unsafe_pbOutput = (byte*)pinned_pbOutput;
					// Call to native method
					unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptExportKey(
										hKey.DangerousGetHandle(), 
										hExportKey.DangerousGetHandle(), 
										unsafe_pszBlobType, 
										unsafe_pbOutput, 
										cbOutput, 
										&(unsafe_pcbResult), 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					pcbResult = unsafe_pcbResult;
				}
			}
			if (addRefed_1)
				hExportKey.DangerousRelease();
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptSecretAgreement, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeKeyHandle__PInvoke_BCrypt____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeSecretHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptSecretAgreementFlags__PInvoke_BCrypt__BCrypt_BCryptSecretAgreementFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptSecretAgreement")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptSecretAgreement(
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt privateKey, 
					global::PInvoke.BCrypt_SafeKeyHandle__PInvoke_BCrypt publicKey, 
					out global::PInvoke.BCrypt_SafeSecretHandle__PInvoke_BCrypt secret, 
					global::PInvoke.BCrypt_BCryptSecretAgreementFlags__PInvoke_BCrypt flags)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			global::System.IntPtr unsafe_secret;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			privateKey.DangerousAddRef(ref addRefed);
			publicKey.DangerousAddRef(ref addRefed_1);
			secret = new global::PInvoke.BCrypt_SafeSecretHandle__PInvoke_BCrypt();
			unsafe_secret = secret.DangerousGetHandle();
			// Call to native method
			unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptSecretAgreement(
								privateKey.DangerousGetHandle(), 
								publicKey.DangerousGetHandle(), 
								&(unsafe_secret), 
								flags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								secret, 
								unsafe_secret
							);
			if (addRefed_1)
				publicKey.DangerousRelease();
			if (addRefed)
				privateKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptDeriveKey, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeSecretHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_BCrypt_BCryptBufferDesc__PInvoke_BCrypt__PInvoke__BCrypt_BCryptBufferDesc__PInvoke_BCrypt, [fwd] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptDeriveKeyFlags__PInvoke_BCrypt__BCrypt_BCryptDeriveKeyFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptDeriveKey")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptDeriveKey(
					global::PInvoke.BCrypt_SafeSecretHandle__PInvoke_BCrypt sharedSecret, 
					string keyDerivationFunction, 
					ref global::PInvoke.BCrypt_BCryptBufferDesc__PInvoke_BCrypt kdfParameters, 
					byte[] derivedKey, 
					int derivedKeySize, 
					out int resultSize, 
					global::PInvoke.BCrypt_BCryptDeriveKeyFlags__PInvoke_BCrypt flags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_keyDerivationFunction = default(ushort*);
			global::PInvoke.BCrypt_BCryptBufferDesc__PInvoke_BCrypt unsafe_kdfParameters;
			byte* unsafe_derivedKey;
			int unsafe_resultSize;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			sharedSecret.DangerousAddRef(ref addRefed);
			fixed (char* pinned_keyDerivationFunction = keyDerivationFunction)
			{
				unsafe_keyDerivationFunction = (ushort*)pinned_keyDerivationFunction;
				unsafe_kdfParameters = kdfParameters;
				fixed (byte* pinned_derivedKey = global::McgInterop.McgCoreHelpers.GetArrayForCompat(derivedKey))
				{
					unsafe_derivedKey = (byte*)pinned_derivedKey;
					// Call to native method
					unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptDeriveKey(
										sharedSecret.DangerousGetHandle(), 
										unsafe_keyDerivationFunction, 
										&(unsafe_kdfParameters), 
										unsafe_derivedKey, 
										derivedKeySize, 
										&(unsafe_resultSize), 
										flags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					resultSize = unsafe_resultSize;
				}
			}
			if (addRefed)
				sharedSecret.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptSetProperty, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptSetPropertyFlags__PInvoke_BCrypt__BCrypt_BCryptSetPropertyFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptSetProperty")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptSetProperty(
					global::System.Runtime.InteropServices.SafeHandle hObject, 
					string pszProperty, 
					byte* pbInput, 
					int cbInput, 
					global::PInvoke.BCrypt_BCryptSetPropertyFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				// Call to native method
				unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptSetProperty(
									hObject.DangerousGetHandle(), 
									unsafe_pszProperty, 
									((byte*)pbInput), 
									cbInput, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptSetProperty__0, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptSetPropertyFlags__PInvoke_BCrypt__BCrypt_BCryptSetPropertyFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptSetProperty")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptSetProperty__0(
					global::System.Runtime.InteropServices.SafeHandle hObject, 
					string pszProperty, 
					string pbInput, 
					int cbInput, 
					global::PInvoke.BCrypt_BCryptSetPropertyFlags__PInvoke_BCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			ushort* unsafe_pbInput = default(ushort*);
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				fixed (char* pinned_pbInput = pbInput)
				{
					unsafe_pbInput = (ushort*)pinned_pbInput;
					// Call to native method
					unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptSetProperty__0(
										hObject.DangerousGetHandle(), 
										unsafe_pszProperty, 
										unsafe_pbInput, 
										cbInput, 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptGetProperty, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptGetPropertyFlags__PInvoke_BCrypt__BCrypt_BCryptGetPropertyFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptGetProperty")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptGetProperty(
					global::System.Runtime.InteropServices.SafeHandle hObject, 
					string property, 
					byte[] output, 
					int outputSize, 
					out int resultSize, 
					global::PInvoke.BCrypt_BCryptGetPropertyFlags__PInvoke_BCrypt flags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_property = default(ushort*);
			byte* unsafe_output;
			int unsafe_resultSize;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_property = property)
			{
				unsafe_property = (ushort*)pinned_property;
				fixed (byte* pinned_output = global::McgInterop.McgCoreHelpers.GetArrayForCompat(output))
				{
					unsafe_output = (byte*)pinned_output;
					// Call to native method
					unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptGetProperty(
										hObject.DangerousGetHandle(), 
										unsafe_property, 
										unsafe_output, 
										outputSize, 
										&(unsafe_resultSize), 
										flags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					resultSize = unsafe_resultSize;
				}
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptGenRandom, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptGenRandomFlags__PInvoke_BCrypt__BCrypt_BCryptGenRandomFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptGenRandom")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptGenRandom(
					global::PInvoke.BCrypt_SafeAlgorithmHandle__PInvoke_BCrypt hAlgorithm, 
					byte[] pbBuffer, 
					int cbBuffer, 
					global::PInvoke.BCrypt_BCryptGenRandomFlags__PInvoke_BCrypt flags)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pbBuffer;
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			hAlgorithm.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pbBuffer = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbBuffer))
			{
				unsafe_pbBuffer = (byte*)pinned_pbBuffer;
				// Call to native method
				unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptGenRandom(
									hAlgorithm.DangerousGetHandle(), 
									unsafe_pbBuffer, 
									cbBuffer, 
									flags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				hAlgorithm.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptFreeBuffer, [fwd] [return] [Mcg.CodeGen.VoidReturnMarshaller] void__void, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptFreeBuffer")]
		public static void BCryptFreeBuffer(void* pvBuffer)
		{
			// Marshalling
			// Call to native method
			global::McgInterop.BCrypt_PInvokes.BCryptFreeBuffer(((void*)pvBuffer));
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
		}

		// Signature, BCryptCloseAlgorithmProvider, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_BCrypt_BCryptCloseAlgorithmProviderFlags__PInvoke_BCrypt__BCrypt_BCryptCloseAlgorithmProviderFlags__PInvoke_BCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptCloseAlgorithmProvider")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptCloseAlgorithmProvider(
					global::System.IntPtr algorithmHandle, 
					global::PInvoke.BCrypt_BCryptCloseAlgorithmProviderFlags__PInvoke_BCrypt flags)
		{
			// Setup
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptCloseAlgorithmProvider(
								algorithmHandle, 
								flags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptDestroyHash, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptDestroyHash")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptDestroyHash(global::System.IntPtr hHash)
		{
			// Setup
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptDestroyHash(hHash);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptDestroyKey, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptDestroyKey")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptDestroyKey(global::System.IntPtr hKey)
		{
			// Setup
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptDestroyKey(hKey);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptDestroySecret, [fwd] [return] [Mcg.CodeGen.BlittableStructMarshaller] PInvoke_NTSTATUS__PInvoke_Windows_Core__PInvoke__NTSTATUS__PInvoke_Windows_Core, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.BCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.BCrypt", "BCryptDestroySecret")]
		public static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptDestroySecret(global::System.IntPtr hSecret)
		{
			// Setup
			global::PInvoke.NTSTATUS__PInvoke_Windows_Core unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.BCrypt_PInvokes.BCryptDestroySecret(hSecret);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-file-l1-2-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_file_l1_2_0_dll
	{
		// Signature, FindFirstFileEx, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_Kernel32_SafeFindFilesHandle__PInvoke_Kernel32____w64 int, [fwd] [in] [Mcg.CodeGen.AnsiStringMarshaller] string__unsigned char *, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_Kernel32_FINDEX_INFO_LEVELS__PInvoke_Kernel32__Kernel32_FINDEX_INFO_LEVELS__PInvoke_Kernel32, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.StructMarshaller] PInvoke_Kernel32_WIN32_FIND_DATA__PInvoke_Kernel32__PInvoke__Kernel32_WIN32_FIND_DATA__PInvoke_Kernel32, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_Kernel32_FINDEX_SEARCH_OPS__PInvoke_Kernel32__Kernel32_FINDEX_SEARCH_OPS__PInvoke_Kernel32, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_Kernel32_FindFirstFileExFlags__PInvoke_Kernel32__Kernel32_FindFirstFileExFlags__PInvoke_Kernel32, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "FindFirstFileEx")]
		public static global::PInvoke.Kernel32_SafeFindFilesHandle__PInvoke_Kernel32 FindFirstFileEx(
					string lpFileName, 
					global::PInvoke.Kernel32_FINDEX_INFO_LEVELS__PInvoke_Kernel32 fInfoLevelId, 
					out global::PInvoke.Kernel32_WIN32_FIND_DATA__PInvoke_Kernel32 lpFindFileData, 
					global::PInvoke.Kernel32_FINDEX_SEARCH_OPS__PInvoke_Kernel32 fSearchOp, 
					void* lpSearchFilter, 
					global::PInvoke.Kernel32_FindFirstFileExFlags__PInvoke_Kernel32 dwAdditionalFlags)
		{
			// Setup
			byte* unsafe_lpFileName = default(byte*);
			global::PInvoke.Kernel32_WIN32_FIND_DATA__PInvoke_Kernel32__Impl.UnsafeType unsafe_lpFindFileData = default(global::PInvoke.Kernel32_WIN32_FIND_DATA__PInvoke_Kernel32__Impl.UnsafeType);
			global::PInvoke.Kernel32_SafeFindFilesHandle__PInvoke_Kernel32 __value;
			global::System.IntPtr unsafe___value;
			try
			{
				// Marshalling
				unsafe_lpFileName = global::System.Runtime.InteropServices.McgMarshal.StringToAnsiString(lpFileName, true, false);
				unsafe_lpFindFileData = default(global::PInvoke.Kernel32_WIN32_FIND_DATA__PInvoke_Kernel32__Impl.UnsafeType);
				__value = new global::PInvoke.Kernel32_SafeFindFilesHandle__PInvoke_Kernel32();
				// Call to native method
				unsafe___value = global::McgInterop.api_ms_win_core_file_l1_2_0_dll_PInvokes.FindFirstFileEx(
									unsafe_lpFileName, 
									fInfoLevelId, 
									&(unsafe_lpFindFileData), 
									fSearchOp, 
									((void*)lpSearchFilter), 
									dwAdditionalFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									__value, 
									unsafe___value
								);
				global::PInvoke.Kernel32_WIN32_FIND_DATA__PInvoke_Kernel32__Impl.Marshal__UnsafeToSafe(
									ref unsafe_lpFindFileData, 
									out lpFindFileData
								);
				// Return
				return __value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_lpFileName);
			}
		}

		// Signature, ReadFile, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_Kernel32_SafeObjectHandle__PInvoke_Kernel32____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int___ptrint *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] PInvoke_Kernel32_OVERLAPPED__PInvoke_Kernel32___ptrPInvoke__Kernel32_OVERLAPPED__PInvoke_Kernel32 *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "ReadFile")]
		public static bool ReadFile(
					global::PInvoke.Kernel32_SafeObjectHandle__PInvoke_Kernel32 hFile, 
					void* lpBuffer, 
					int nNumberOfBytesToRead, 
					int* lpNumberOfBytesRead, 
					global::PInvoke.Kernel32_OVERLAPPED__PInvoke_Kernel32* lpOverlapped)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hFile.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_2_0_dll_PInvokes.ReadFile(
								hFile.DangerousGetHandle(), 
								((void*)lpBuffer), 
								nNumberOfBytesToRead, 
								((int*)lpNumberOfBytesRead), 
								((global::PInvoke.Kernel32_OVERLAPPED__PInvoke_Kernel32*)lpOverlapped)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hFile.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, WriteFile, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_Kernel32_SafeObjectHandle__PInvoke_Kernel32____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int___ptrint *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] PInvoke_Kernel32_OVERLAPPED__PInvoke_Kernel32___ptrPInvoke__Kernel32_OVERLAPPED__PInvoke_Kernel32 *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "WriteFile")]
		public static bool WriteFile(
					global::PInvoke.Kernel32_SafeObjectHandle__PInvoke_Kernel32 hFile, 
					void* lpBuffer, 
					int nNumberOfBytesToWrite, 
					int* lpNumberOfBytesWritten, 
					global::PInvoke.Kernel32_OVERLAPPED__PInvoke_Kernel32* lpOverlapped)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hFile.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_2_0_dll_PInvokes.WriteFile(
								hFile.DangerousGetHandle(), 
								((void*)lpBuffer), 
								nNumberOfBytesToWrite, 
								((int*)lpNumberOfBytesWritten), 
								((global::PInvoke.Kernel32_OVERLAPPED__PInvoke_Kernel32*)lpOverlapped)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hFile.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, FlushFileBuffers, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_Kernel32_SafeObjectHandle__PInvoke_Kernel32____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "FlushFileBuffers")]
		public static bool FlushFileBuffers(global::PInvoke.Kernel32_SafeObjectHandle__PInvoke_Kernel32 hFile)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hFile.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_2_0_dll_PInvokes.FlushFileBuffers(hFile.DangerousGetHandle());
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hFile.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, FindClose, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "FindClose")]
		public static bool FindClose(global::System.IntPtr hFindFile)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_2_0_dll_PInvokes.FindClose(hFindFile);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CreateFile2, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeFileHandle__System_IO_FileSystem____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_IO_FileShare__System_IO_FileSystem_Primitives__FileShare__System_IO_FileSystem_Primitives, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_IO_FileMode__System_IO_FileSystem_Primitives__FileMode__System_IO_FileSystem_Primitives, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Interop_mincore_CREATEFILE2_EXTENDED_PARAMETERS__System_IO_FileSystem____Interop_mincore_CREATEFILE2_EXTENDED_PARAMETERS__System_IO_FileSystem, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "CreateFile2")]
		public static global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_IO_FileSystem CreateFile2(
					string lpFileName, 
					int dwDesiredAccess, 
					global::System.IO.FileShare__System_IO_FileSystem_Primitives dwShareMode, 
					global::System.IO.FileMode__System_IO_FileSystem_Primitives dwCreationDisposition, 
					ref global::Interop_mincore_CREATEFILE2_EXTENDED_PARAMETERS__System_IO_FileSystem parameters)
		{
			// Setup
			ushort* unsafe_lpFileName = default(ushort*);
			global::Interop_mincore_CREATEFILE2_EXTENDED_PARAMETERS__System_IO_FileSystem unsafe_parameters;
			global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_IO_FileSystem __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			fixed (char* pinned_lpFileName = lpFileName)
			{
				unsafe_lpFileName = (ushort*)pinned_lpFileName;
				unsafe_parameters = parameters;
				__value = new global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_IO_FileSystem();
				// Call to native method
				unsafe___value = global::McgInterop.api_ms_win_core_file_l1_2_0_dll_PInvokes.CreateFile2(
									unsafe_lpFileName, 
									dwDesiredAccess, 
									dwShareMode, 
									dwCreationDisposition, 
									&(unsafe_parameters)
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									__value, 
									unsafe___value
								);
			}
			// Return
			return __value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-localization-l1-2-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_localization_l1_2_0_dll
	{
		// Signature, FormatMessage, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_Kernel32_FormatMessageFlags__PInvoke_Kernel32__Kernel32_FormatMessageFlags__PInvoke_Kernel32, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "FormatMessage")]
		public static int FormatMessage(
					global::PInvoke.Kernel32_FormatMessageFlags__PInvoke_Kernel32 dwFlags, 
					void* lpSource, 
					int dwMessageId, 
					int dwLanguageId, 
					global::System.Text.StringBuilder lpBuffer, 
					int nSize, 
					global::System.IntPtr[] Arguments)
		{
			// Setup
			ushort* unsafe_lpBuffer = default(ushort*);
			global::System.IntPtr* unsafe_Arguments;
			int unsafe___value;
			try
			{
				// Marshalling
				if (lpBuffer == null)
					unsafe_lpBuffer = null;
				else
				{
					unsafe_lpBuffer = (ushort*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(lpBuffer.Capacity * 2 
										+ 2)));
					if (unsafe_lpBuffer == null)
						throw new global::System.OutOfMemoryException();
				}
				if (unsafe_lpBuffer != null)
					global::System.Runtime.InteropServices.McgMarshal.StringBuilderToUnicodeString(
										lpBuffer, 
										unsafe_lpBuffer
									);
				fixed (global::System.IntPtr* pinned_Arguments = global::McgInterop.McgCoreHelpers.GetArrayForCompat(Arguments))
				{
					unsafe_Arguments = (global::System.IntPtr*)pinned_Arguments;
					// Call to native method
					unsafe___value = global::McgInterop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.FormatMessage(
										dwFlags, 
										((void*)lpSource), 
										dwMessageId, 
										dwLanguageId, 
										unsafe_lpBuffer, 
										nSize, 
										unsafe_Arguments
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
				if (lpBuffer != null)
					global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
										unsafe_lpBuffer, 
										lpBuffer
									);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_lpBuffer != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_lpBuffer);
			}
		}

		// Signature, IsValidLocaleName, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] char___ptrwchar_t *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "IsValidLocaleName")]
		public static int IsValidLocaleName(char* lpLocaleName)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.IsValidLocaleName(((ushort*)lpLocaleName));
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}

		// Signature, ResolveLocaleName, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] char___ptrwchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] char___ptrwchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "ResolveLocaleName")]
		public static int ResolveLocaleName(
					char* lpNameToResolve, 
					char* lpLocaleName, 
					int cchLocaleName)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.ResolveLocaleName(
								((ushort*)lpNameToResolve), 
								((ushort*)lpLocaleName), 
								cchLocaleName
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}

		// Signature, GetCPInfoExW, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] Interop_mincore_CPINFOEXW__System_Text_Encoding_CodePages___ptr__Interop_mincore_CPINFOEXW__System_Text_Encoding_CodePages *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Text.Encoding.CodePages, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "GetCPInfoExW")]
		public static int GetCPInfoExW(
					uint CodePage, 
					uint dwFlags, 
					global::Interop_mincore_CPINFOEXW__System_Text_Encoding_CodePages* lpCPInfoEx)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.GetCPInfoExW(
								CodePage, 
								dwFlags, 
								((global::Interop_mincore_CPINFOEXW__System_Text_Encoding_CodePages*)lpCPInfoEx)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage__0, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("Microsoft.Win32.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "FormatMessage")]
		public static int FormatMessage__0(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					global::System.Text.StringBuilder lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			ushort* unsafe_lpBuffer = default(ushort*);
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			try
			{
				// Marshalling
				if (lpBuffer == null)
					unsafe_lpBuffer = null;
				else
				{
					unsafe_lpBuffer = (ushort*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(lpBuffer.Capacity * 2 
										+ 2)));
					if (unsafe_lpBuffer == null)
						throw new global::System.OutOfMemoryException();
				}
				fixed (global::System.IntPtr* pinned_arguments = global::McgInterop.McgCoreHelpers.GetArrayForCompat(arguments))
				{
					unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
					// Call to native method
					unsafe___value = global::McgInterop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.FormatMessage__0(
										dwFlags, 
										lpSource, 
										dwMessageId, 
										dwLanguageId, 
										unsafe_lpBuffer, 
										nSize, 
										unsafe_arguments
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
				if (lpBuffer != null)
					global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
										unsafe_lpBuffer, 
										lpBuffer
									);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_lpBuffer != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_lpBuffer);
			}
		}

		// Signature, FormatMessage__1, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+mincore", "FormatMessage")]
		public static int FormatMessage__1(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					global::System.Text.StringBuilder lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			ushort* unsafe_lpBuffer = default(ushort*);
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			try
			{
				// Marshalling
				if (lpBuffer == null)
					unsafe_lpBuffer = null;
				else
				{
					unsafe_lpBuffer = (ushort*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(lpBuffer.Capacity * 2 
										+ 2)));
					if (unsafe_lpBuffer == null)
						throw new global::System.OutOfMemoryException();
				}
				fixed (global::System.IntPtr* pinned_arguments = global::McgInterop.McgCoreHelpers.GetArrayForCompat(arguments))
				{
					unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
					// Call to native method
					unsafe___value = global::McgInterop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.FormatMessage__1(
										dwFlags, 
										lpSource, 
										dwMessageId, 
										dwLanguageId, 
										unsafe_lpBuffer, 
										nSize, 
										unsafe_arguments
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
				if (lpBuffer != null)
					global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
										unsafe_lpBuffer, 
										lpBuffer
									);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_lpBuffer != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_lpBuffer);
			}
		}

		// Signature, FormatMessage__2, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "FormatMessage")]
		public static int FormatMessage__2(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					global::System.Text.StringBuilder lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			ushort* unsafe_lpBuffer = default(ushort*);
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			try
			{
				// Marshalling
				if (lpBuffer == null)
					unsafe_lpBuffer = null;
				else
				{
					unsafe_lpBuffer = (ushort*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(lpBuffer.Capacity * 2 
										+ 2)));
					if (unsafe_lpBuffer == null)
						throw new global::System.OutOfMemoryException();
				}
				fixed (global::System.IntPtr* pinned_arguments = global::McgInterop.McgCoreHelpers.GetArrayForCompat(arguments))
				{
					unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
					// Call to native method
					unsafe___value = global::McgInterop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.FormatMessage__2(
										dwFlags, 
										lpSource, 
										dwMessageId, 
										dwLanguageId, 
										unsafe_lpBuffer, 
										nSize, 
										unsafe_arguments
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
				if (lpBuffer != null)
					global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
										unsafe_lpBuffer, 
										lpBuffer
									);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_lpBuffer != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_lpBuffer);
			}
		}

		// Signature, FormatMessage__3, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "FormatMessage")]
		public static int FormatMessage__3(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					global::System.Text.StringBuilder lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			ushort* unsafe_lpBuffer = default(ushort*);
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			try
			{
				// Marshalling
				if (lpBuffer == null)
					unsafe_lpBuffer = null;
				else
				{
					unsafe_lpBuffer = (ushort*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(lpBuffer.Capacity * 2 
										+ 2)));
					if (unsafe_lpBuffer == null)
						throw new global::System.OutOfMemoryException();
				}
				fixed (global::System.IntPtr* pinned_arguments = global::McgInterop.McgCoreHelpers.GetArrayForCompat(arguments))
				{
					unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
					// Call to native method
					unsafe___value = global::McgInterop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.FormatMessage__3(
										dwFlags, 
										lpSource, 
										dwMessageId, 
										dwLanguageId, 
										unsafe_lpBuffer, 
										nSize, 
										unsafe_arguments
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
				if (lpBuffer != null)
					global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
										unsafe_lpBuffer, 
										lpBuffer
									);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_lpBuffer != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_lpBuffer);
			}
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-processthreads-l1-1-1.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_processthreads_l1_1_1_dll
	{
		// Signature, GetCurrentThreadId, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "GetCurrentThreadId")]
		public static int GetCurrentThreadId()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_processthreads_l1_1_1_dll_PInvokes.GetCurrentThreadId();
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}

		// Signature, GetCurrentProcessId, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "GetCurrentProcessId")]
		public static int GetCurrentProcessId()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_processthreads_l1_1_1_dll_PInvokes.GetCurrentProcessId();
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}

		// Signature, GetCurrentProcess, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_Kernel32_SafeObjectHandle__PInvoke_Kernel32____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "GetCurrentProcess")]
		public static global::PInvoke.Kernel32_SafeObjectHandle__PInvoke_Kernel32 GetCurrentProcess()
		{
			// Setup
			global::PInvoke.Kernel32_SafeObjectHandle__PInvoke_Kernel32 __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::PInvoke.Kernel32_SafeObjectHandle__PInvoke_Kernel32();
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_processthreads_l1_1_1_dll_PInvokes.GetCurrentProcess();
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, SuspendThread, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_Kernel32_SafeObjectHandle__PInvoke_Kernel32____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "SuspendThread")]
		public static int SuspendThread(global::PInvoke.Kernel32_SafeObjectHandle__PInvoke_Kernel32 hThread)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hThread.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_processthreads_l1_1_1_dll_PInvokes.SuspendThread(hThread.DangerousGetHandle());
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hThread.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, ResumeThread, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_Kernel32_SafeObjectHandle__PInvoke_Kernel32____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "ResumeThread")]
		public static int ResumeThread(global::PInvoke.Kernel32_SafeObjectHandle__PInvoke_Kernel32 hThread)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hThread.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_processthreads_l1_1_1_dll_PInvokes.ResumeThread(hThread.DangerousGetHandle());
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hThread.DangerousRelease();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-io-l1-1-1.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_io_l1_1_1_dll
	{
		// Signature, CancelIoEx, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_Kernel32_SafeObjectHandle__PInvoke_Kernel32____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] PInvoke_Kernel32_OVERLAPPED__PInvoke_Kernel32___ptrPInvoke__Kernel32_OVERLAPPED__PInvoke_Kernel32 *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "CancelIoEx")]
		public static bool CancelIoEx(
					global::PInvoke.Kernel32_SafeObjectHandle__PInvoke_Kernel32 hFile, 
					global::PInvoke.Kernel32_OVERLAPPED__PInvoke_Kernel32* lpOverlapped)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hFile.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_io_l1_1_1_dll_PInvokes.CancelIoEx(
								hFile.DangerousGetHandle(), 
								((global::PInvoke.Kernel32_OVERLAPPED__PInvoke_Kernel32*)lpOverlapped)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hFile.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-synch-l1-2-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_synch_l1_2_0_dll
	{
		// Signature, WaitForSingleObject, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_Kernel32_WaitForSingleObjectResult__PInvoke_Kernel32__Kernel32_WaitForSingleObjectResult__PInvoke_Kernel32, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "WaitForSingleObject")]
		public static global::PInvoke.Kernel32_WaitForSingleObjectResult__PInvoke_Kernel32 WaitForSingleObject(
					global::System.Runtime.InteropServices.SafeHandle hHandle, 
					int dwMilliseconds)
		{
			// Setup
			bool addRefed = false;
			global::PInvoke.Kernel32_WaitForSingleObjectResult__PInvoke_Kernel32 unsafe___value;
			// Marshalling
			hHandle.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_synch_l1_2_0_dll_PInvokes.WaitForSingleObject(
								hHandle.DangerousGetHandle(), 
								dwMilliseconds
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-handle-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_handle_l1_1_0_dll
	{
		// Signature, CloseHandle, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.Kernel32, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.Kernel32", "CloseHandle")]
		public static bool CloseHandle(global::System.IntPtr hObject)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_handle_l1_1_0_dll_PInvokes.CloseHandle(hObject);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CloseHandle__0, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "CloseHandle")]
		public static bool CloseHandle__0(global::System.IntPtr handle)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_handle_l1_1_0_dll_PInvokes.CloseHandle__0(handle);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'NCrypt'
	/// </summary>
	public unsafe static partial class NCrypt
	{
		// Signature, NCryptOpenStorageProvider, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeProviderHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptOpenStorageProviderFlags__PInvoke_NCrypt__NCrypt_NCryptOpenStorageProviderFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptOpenStorageProvider")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptOpenStorageProvider(
					out global::PInvoke.NCrypt_SafeProviderHandle__PInvoke_NCrypt phProvider, 
					string pszProviderName, 
					global::PInvoke.NCrypt_NCryptOpenStorageProviderFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			global::System.IntPtr unsafe_phProvider;
			ushort* unsafe_pszProviderName = default(ushort*);
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			phProvider = new global::PInvoke.NCrypt_SafeProviderHandle__PInvoke_NCrypt();
			unsafe_phProvider = phProvider.DangerousGetHandle();
			fixed (char* pinned_pszProviderName = pszProviderName)
			{
				unsafe_pszProviderName = (ushort*)pinned_pszProviderName;
				// Call to native method
				unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptOpenStorageProvider(
									&(unsafe_phProvider), 
									unsafe_pszProviderName, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phProvider, 
								unsafe_phProvider
							);
			// Return
			return unsafe___value;
		}

		// Signature, NCryptCreatePersistedKey, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeProviderHandle__PInvoke_NCrypt____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [optional] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_LegacyKeySpec__PInvoke_NCrypt__NCrypt_LegacyKeySpec__PInvoke_NCrypt, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptCreatePersistedKeyFlags__PInvoke_NCrypt__NCrypt_NCryptCreatePersistedKeyFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptCreatePersistedKey")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptCreatePersistedKey(
					global::PInvoke.NCrypt_SafeProviderHandle__PInvoke_NCrypt hProvider, 
					out global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt phKey, 
					string pszAlgId, 
					string pszKeyName, 
					global::PInvoke.NCrypt_LegacyKeySpec__PInvoke_NCrypt dwLegacyKeySpec, 
					global::PInvoke.NCrypt_NCryptCreatePersistedKeyFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_phKey;
			ushort* unsafe_pszAlgId = default(ushort*);
			ushort* unsafe_pszKeyName = default(ushort*);
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			phKey = new global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt();
			unsafe_phKey = phKey.DangerousGetHandle();
			fixed (char* pinned_pszAlgId = pszAlgId)
			{
				unsafe_pszAlgId = (ushort*)pinned_pszAlgId;
				fixed (char* pinned_pszKeyName = pszKeyName)
				{
					unsafe_pszKeyName = (ushort*)pinned_pszKeyName;
					// Call to native method
					unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptCreatePersistedKey(
										hProvider.DangerousGetHandle(), 
										&(unsafe_phKey), 
										unsafe_pszAlgId, 
										unsafe_pszKeyName, 
										dwLegacyKeySpec, 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				}
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phKey, 
								unsafe_phKey
							);
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptOpenKey, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeProviderHandle__PInvoke_NCrypt____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_LegacyKeySpec__PInvoke_NCrypt__NCrypt_LegacyKeySpec__PInvoke_NCrypt, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptOpenKeyFlags__PInvoke_NCrypt__NCrypt_NCryptOpenKeyFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptOpenKey")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptOpenKey(
					global::PInvoke.NCrypt_SafeProviderHandle__PInvoke_NCrypt hProvider, 
					out global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt phKey, 
					string pszKeyName, 
					global::PInvoke.NCrypt_LegacyKeySpec__PInvoke_NCrypt dwLegacyKeySpec, 
					global::PInvoke.NCrypt_NCryptOpenKeyFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_phKey;
			ushort* unsafe_pszKeyName = default(ushort*);
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			phKey = new global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt();
			unsafe_phKey = phKey.DangerousGetHandle();
			fixed (char* pinned_pszKeyName = pszKeyName)
			{
				unsafe_pszKeyName = (ushort*)pinned_pszKeyName;
				// Call to native method
				unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptOpenKey(
									hProvider.DangerousGetHandle(), 
									&(unsafe_phKey), 
									unsafe_pszKeyName, 
									dwLegacyKeySpec, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phKey, 
								unsafe_phKey
							);
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptDeleteKey, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptDeleteKeyFlags__PInvoke_NCrypt__NCrypt_NCryptDeleteKeyFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptDeleteKey")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptDeleteKey(
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hKey, 
					global::PInvoke.NCrypt_NCryptDeleteKeyFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptDeleteKey(
								hKey.DangerousGetHandle(), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptSecretAgreement, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeSecretHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptSecretAgreementFlags__PInvoke_NCrypt__NCrypt_NCryptSecretAgreementFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptSecretAgreement")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptSecretAgreement(
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hPrivKey, 
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hPubKey, 
					out global::PInvoke.NCrypt_SafeSecretHandle__PInvoke_NCrypt phSecret, 
					global::PInvoke.NCrypt_NCryptSecretAgreementFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			global::System.IntPtr unsafe_phSecret;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hPrivKey.DangerousAddRef(ref addRefed);
			hPubKey.DangerousAddRef(ref addRefed_1);
			phSecret = new global::PInvoke.NCrypt_SafeSecretHandle__PInvoke_NCrypt();
			unsafe_phSecret = phSecret.DangerousGetHandle();
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptSecretAgreement(
								hPrivKey.DangerousGetHandle(), 
								hPubKey.DangerousGetHandle(), 
								&(unsafe_phSecret), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phSecret, 
								unsafe_phSecret
							);
			if (addRefed_1)
				hPubKey.DangerousRelease();
			if (addRefed)
				hPrivKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptKeyDerivation, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] PInvoke_NCrypt_NCryptBufferDesc__PInvoke_NCrypt___ptrPInvoke__NCrypt_NCryptBufferDesc__PInvoke_NCrypt *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptKeyDerivationFlags__PInvoke_NCrypt__NCrypt_NCryptKeyDerivationFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptKeyDerivation")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptKeyDerivation(
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hKey, 
					global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt* pParameterList, 
					byte* pbDerivedKey, 
					int cbDerivedKey, 
					out int pcbResult, 
					global::PInvoke.NCrypt_NCryptKeyDerivationFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe_pcbResult;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptKeyDerivation(
								hKey.DangerousGetHandle(), 
								((global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt*)pParameterList), 
								((byte*)pbDerivedKey), 
								cbDerivedKey, 
								&(unsafe_pcbResult), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			pcbResult = unsafe_pcbResult;
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptDeriveKey, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeSecretHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] PInvoke_NCrypt_NCryptBufferDesc__PInvoke_NCrypt___ptrPInvoke__NCrypt_NCryptBufferDesc__PInvoke_NCrypt *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptDeriveKeyFlags__PInvoke_NCrypt__NCrypt_NCryptDeriveKeyFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptDeriveKey")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptDeriveKey(
					global::PInvoke.NCrypt_SafeSecretHandle__PInvoke_NCrypt hSharedSecret, 
					string pwszKDF, 
					global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt* pParameterList, 
					byte* pbDerivedKey, 
					int cbDerivedKey, 
					out int pcbResult, 
					global::PInvoke.NCrypt_NCryptDeriveKeyFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pwszKDF = default(ushort*);
			int unsafe_pcbResult;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hSharedSecret.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pwszKDF = pwszKDF)
			{
				unsafe_pwszKDF = (ushort*)pinned_pwszKDF;
				// Call to native method
				unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptDeriveKey(
									hSharedSecret.DangerousGetHandle(), 
									unsafe_pwszKDF, 
									((global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt*)pParameterList), 
									((byte*)pbDerivedKey), 
									cbDerivedKey, 
									&(unsafe_pcbResult), 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				pcbResult = unsafe_pcbResult;
			}
			if (addRefed)
				hSharedSecret.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptEnumAlgorithms, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeProviderHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_AlgorithmOperations__PInvoke_NCrypt__NCrypt_AlgorithmOperations__PInvoke_NCrypt, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] PInvoke_NCrypt_NCryptAlgorithmName__PInvoke_NCrypt___ptrPInvoke__NCrypt_NCryptAlgorithmName__PInvoke_NCrypt *, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptEnumAlgorithmsFlags__PInvoke_NCrypt__NCrypt_NCryptEnumAlgorithmsFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptEnumAlgorithms")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptEnumAlgorithms(
					global::PInvoke.NCrypt_SafeProviderHandle__PInvoke_NCrypt hProvider, 
					global::PInvoke.NCrypt_AlgorithmOperations__PInvoke_NCrypt dwAlgOperations, 
					out int pdwAlgCount, 
					out global::PInvoke.NCrypt_NCryptAlgorithmName__PInvoke_NCrypt* ppAlgList, 
					global::PInvoke.NCrypt_NCryptEnumAlgorithmsFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe_pdwAlgCount;
			global::PInvoke.NCrypt_NCryptAlgorithmName__PInvoke_NCrypt* unsafe_ppAlgList;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptEnumAlgorithms(
								hProvider.DangerousGetHandle(), 
								dwAlgOperations, 
								&(unsafe_pdwAlgCount), 
								&(unsafe_ppAlgList), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			ppAlgList = (global::PInvoke.NCrypt_NCryptAlgorithmName__PInvoke_NCrypt*)unsafe_ppAlgList;
			pdwAlgCount = unsafe_pdwAlgCount;
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptEnumKeys, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeProviderHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] PInvoke_NCrypt_NCryptKeyName__PInvoke_NCrypt___ptrPInvoke__NCrypt_NCryptKeyName__PInvoke_NCrypt *, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptEnumKeysFlags__PInvoke_NCrypt__NCrypt_NCryptEnumKeysFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptEnumKeys")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptEnumKeys(
					global::PInvoke.NCrypt_SafeProviderHandle__PInvoke_NCrypt hProvider, 
					string pszScope, 
					out global::PInvoke.NCrypt_NCryptKeyName__PInvoke_NCrypt* ppKeyName, 
					ref void* ppEnumState, 
					global::PInvoke.NCrypt_NCryptEnumKeysFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszScope = default(ushort*);
			global::PInvoke.NCrypt_NCryptKeyName__PInvoke_NCrypt* unsafe_ppKeyName;
			void* unsafe_ppEnumState;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszScope = pszScope)
			{
				unsafe_pszScope = (ushort*)pinned_pszScope;
				unsafe_ppEnumState = (void*)ppEnumState;
				// Call to native method
				unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptEnumKeys(
									hProvider.DangerousGetHandle(), 
									unsafe_pszScope, 
									&(unsafe_ppKeyName), 
									&(unsafe_ppEnumState), 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				ppEnumState = (void*)unsafe_ppEnumState;
				ppKeyName = (global::PInvoke.NCrypt_NCryptKeyName__PInvoke_NCrypt*)unsafe_ppKeyName;
			}
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptIsAlgSupported, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeProviderHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptIsAlgSupportedFlags__PInvoke_NCrypt__NCrypt_NCryptIsAlgSupportedFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptIsAlgSupported")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptIsAlgSupported(
					global::PInvoke.NCrypt_SafeProviderHandle__PInvoke_NCrypt hProvider, 
					string pszAlgId, 
					global::PInvoke.NCrypt_NCryptIsAlgSupportedFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszAlgId = default(ushort*);
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszAlgId = pszAlgId)
			{
				unsafe_pszAlgId = (ushort*)pinned_pszAlgId;
				// Call to native method
				unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptIsAlgSupported(
									hProvider.DangerousGetHandle(), 
									unsafe_pszAlgId, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			}
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptFinalizeKey, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptFinalizeKeyFlags__PInvoke_NCrypt__NCrypt_NCryptFinalizeKeyFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptFinalizeKey")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptFinalizeKey(
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hKey, 
					global::PInvoke.NCrypt_NCryptFinalizeKeyFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptFinalizeKey(
								hKey.DangerousGetHandle(), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptExportKey, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] PInvoke_NCrypt_NCryptBufferDesc__PInvoke_NCrypt___ptrPInvoke__NCrypt_NCryptBufferDesc__PInvoke_NCrypt *, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptExportKeyFlags__PInvoke_NCrypt__NCrypt_NCryptExportKeyFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptExportKey")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptExportKey(
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hKey, 
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hExportKey, 
					string pszBlobType, 
					global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt* pParameterList, 
					byte[] pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					global::PInvoke.NCrypt_NCryptExportKeyFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			ushort* unsafe_pszBlobType = default(ushort*);
			byte* unsafe_pbOutput;
			int unsafe_pcbResult;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			hExportKey.DangerousAddRef(ref addRefed_1);
			fixed (char* pinned_pszBlobType = pszBlobType)
			{
				unsafe_pszBlobType = (ushort*)pinned_pszBlobType;
				fixed (byte* pinned_pbOutput = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbOutput))
				{
					unsafe_pbOutput = (byte*)pinned_pbOutput;
					// Call to native method
					unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptExportKey(
										hKey.DangerousGetHandle(), 
										hExportKey.DangerousGetHandle(), 
										unsafe_pszBlobType, 
										((global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt*)pParameterList), 
										unsafe_pbOutput, 
										cbOutput, 
										&(unsafe_pcbResult), 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					pcbResult = unsafe_pcbResult;
				}
			}
			if (addRefed_1)
				hExportKey.DangerousRelease();
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptImportKey, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeProviderHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] PInvoke_NCrypt_NCryptBufferDesc__PInvoke_NCrypt___ptrPInvoke__NCrypt_NCryptBufferDesc__PInvoke_NCrypt *, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptExportKeyFlags__PInvoke_NCrypt__NCrypt_NCryptExportKeyFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptImportKey")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptImportKey(
					global::PInvoke.NCrypt_SafeProviderHandle__PInvoke_NCrypt hProvider, 
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hImportKey, 
					string pszBlobType, 
					global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt* pParameterList, 
					out global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt phKey, 
					byte* pbData, 
					int cbData, 
					global::PInvoke.NCrypt_NCryptExportKeyFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			ushort* unsafe_pszBlobType = default(ushort*);
			global::System.IntPtr unsafe_phKey;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			hImportKey.DangerousAddRef(ref addRefed_1);
			fixed (char* pinned_pszBlobType = pszBlobType)
			{
				unsafe_pszBlobType = (ushort*)pinned_pszBlobType;
				phKey = new global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt();
				unsafe_phKey = phKey.DangerousGetHandle();
				// Call to native method
				unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptImportKey(
									hProvider.DangerousGetHandle(), 
									hImportKey.DangerousGetHandle(), 
									unsafe_pszBlobType, 
									((global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt*)pParameterList), 
									&(unsafe_phKey), 
									((byte*)pbData), 
									cbData, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									phKey, 
									unsafe_phKey
								);
			}
			if (addRefed_1)
				hImportKey.DangerousRelease();
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptGetProperty, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptGetPropertyFlags__PInvoke_NCrypt__NCrypt_NCryptGetPropertyFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptGetProperty")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptGetProperty(
					global::System.Runtime.InteropServices.SafeHandle hObject, 
					string pszProperty, 
					byte[] pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					global::PInvoke.NCrypt_NCryptGetPropertyFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			byte* unsafe_pbOutput;
			int unsafe_pcbResult = 0;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				fixed (byte* pinned_pbOutput = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pbOutput))
				{
					unsafe_pbOutput = (byte*)pinned_pbOutput;
					// Call to native method
					unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptGetProperty(
										hObject.DangerousGetHandle(), 
										unsafe_pszProperty, 
										unsafe_pbOutput, 
										cbOutput, 
										&(unsafe_pcbResult), 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					pcbResult = unsafe_pcbResult;
				}
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptSetProperty, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptSetPropertyFlags__PInvoke_NCrypt__NCrypt_NCryptSetPropertyFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptSetProperty")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptSetProperty(
					global::System.Runtime.InteropServices.SafeHandle hObject, 
					string pszProperty, 
					byte* pbInput, 
					int cbInput, 
					global::PInvoke.NCrypt_NCryptSetPropertyFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				// Call to native method
				unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptSetProperty(
									hObject.DangerousGetHandle(), 
									unsafe_pszProperty, 
									((byte*)pbInput), 
									cbInput, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptSetProperty__0, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptSetPropertyFlags__PInvoke_NCrypt__NCrypt_NCryptSetPropertyFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptSetProperty")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptSetProperty__0(
					global::System.Runtime.InteropServices.SafeHandle hObject, 
					string pszProperty, 
					string pbInput, 
					int cbInput, 
					global::PInvoke.NCrypt_NCryptSetPropertyFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			ushort* unsafe_pbInput = default(ushort*);
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				fixed (char* pinned_pbInput = pbInput)
				{
					unsafe_pbInput = (ushort*)pinned_pbInput;
					// Call to native method
					unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptSetProperty__0(
										hObject.DangerousGetHandle(), 
										unsafe_pszProperty, 
										unsafe_pbInput, 
										cbInput, 
										dwFlags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				}
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptEncrypt, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptEncryptFlags__PInvoke_NCrypt__NCrypt_NCryptEncryptFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptEncrypt")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptEncrypt(
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hKey, 
					byte* pbInput, 
					int cbInput, 
					void* pPaddingInfo, 
					byte* pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					global::PInvoke.NCrypt_NCryptEncryptFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe_pcbResult;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptEncrypt(
								hKey.DangerousGetHandle(), 
								((byte*)pbInput), 
								cbInput, 
								((void*)pPaddingInfo), 
								((byte*)pbOutput), 
								cbOutput, 
								&(unsafe_pcbResult), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			pcbResult = unsafe_pcbResult;
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptDecrypt, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptEncryptFlags__PInvoke_NCrypt__NCrypt_NCryptEncryptFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptDecrypt")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptDecrypt(
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hKey, 
					byte* pbInput, 
					int cbInput, 
					void* pPaddingInfo, 
					byte* pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					global::PInvoke.NCrypt_NCryptEncryptFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe_pcbResult;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptDecrypt(
								hKey.DangerousGetHandle(), 
								((byte*)pbInput), 
								cbInput, 
								((void*)pPaddingInfo), 
								((byte*)pbOutput), 
								cbOutput, 
								&(unsafe_pcbResult), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			pcbResult = unsafe_pcbResult;
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptSignHash, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptSignHashFlags__PInvoke_NCrypt__NCrypt_NCryptSignHashFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptSignHash")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptSignHash(
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hKey, 
					void* pPaddingInfo, 
					byte* pbHashValue, 
					int cbHashValue, 
					byte* pbSignature, 
					int cbSignature, 
					out int pcbResult, 
					global::PInvoke.NCrypt_NCryptSignHashFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe_pcbResult;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptSignHash(
								hKey.DangerousGetHandle(), 
								((void*)pPaddingInfo), 
								((byte*)pbHashValue), 
								cbHashValue, 
								((byte*)pbSignature), 
								cbSignature, 
								&(unsafe_pcbResult), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			pcbResult = unsafe_pcbResult;
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptVerifySignature, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] PInvoke_NCrypt_SafeKeyHandle__PInvoke_NCrypt____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [optional] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_NCryptSignHashFlags__PInvoke_NCrypt__NCrypt_NCryptSignHashFlags__PInvoke_NCrypt, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptVerifySignature")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptVerifySignature(
					global::PInvoke.NCrypt_SafeKeyHandle__PInvoke_NCrypt hKey, 
					void* pPaddingInfo, 
					byte* pbHashValue, 
					int cbHashValue, 
					byte* pbSignature, 
					int cbSignature, 
					global::PInvoke.NCrypt_NCryptSignHashFlags__PInvoke_NCrypt dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptVerifySignature(
								hKey.DangerousGetHandle(), 
								((void*)pPaddingInfo), 
								((byte*)pbHashValue), 
								cbHashValue, 
								((byte*)pbSignature), 
								cbSignature, 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptFreeBuffer, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptFreeBuffer")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptFreeBuffer(void* pvInput)
		{
			// Setup
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptFreeBuffer(((void*)pvInput));
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptFreeObject, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] PInvoke_NCrypt_SECURITY_STATUS__PInvoke_NCrypt__NCrypt_SECURITY_STATUS__PInvoke_NCrypt, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("PInvoke.NCrypt, Version=0.3.0.0, Culture=neutral, PublicKeyToken=9e300f9f87f04a7a", "PInvoke.NCrypt", "NCryptFreeObject")]
		public static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptFreeObject(global::System.IntPtr hObject)
		{
			// Setup
			global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.NCrypt_PInvokes.NCryptFreeObject(hObject);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module '[MRT]'
	/// </summary>
	public unsafe static partial class _MRT_
	{
		// Signature, RhWaitForPendingFinalizers, [fwd] [return] [Mcg.CodeGen.VoidReturnMarshaller] void__void, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhWaitForPendingFinalizers")]
		public static void RhWaitForPendingFinalizers(int allowReentrantWait)
		{
			// Marshalling
			// Call to native method
			global::McgInterop._MRT__PInvokes.RhWaitForPendingFinalizers(allowReentrantWait);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
		}

		// Signature, RhCompatibleReentrantWaitAny, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr___ptr__w64 int *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhCompatibleReentrantWaitAny")]
		public static int RhCompatibleReentrantWaitAny(
					int alertable, 
					int timeout, 
					int count, 
					global::System.IntPtr* handles)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop._MRT__PInvokes.RhCompatibleReentrantWaitAny(
								alertable, 
								timeout, 
								count, 
								((global::System.IntPtr*)handles)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}

		// Signature, _ecvt_s, [fwd] [return] [Mcg.CodeGen.VoidReturnMarshaller] void__void, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] double__double, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int___ptrint *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int___ptrint *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "_ecvt_s")]
		public static void _ecvt_s(
					byte* buffer, 
					int sizeInBytes, 
					double value, 
					int count, 
					int* dec, 
					int* sign)
		{
			// Marshalling
			// Call to native method
			global::McgInterop._MRT__PInvokes._ecvt_s(
								((byte*)buffer), 
								sizeInBytes, 
								value, 
								count, 
								((int*)dec), 
								((int*)sign)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
		}

		// Signature, memmove, [fwd] [return] [Mcg.CodeGen.VoidReturnMarshaller] void__void, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "memmove")]
		public static void memmove(
					byte* dmem, 
					byte* smem, 
					uint size)
		{
			// Marshalling
			// Call to native method
			global::McgInterop._MRT__PInvokes.memmove(
								((byte*)dmem), 
								((byte*)smem), 
								size
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module '*'
	/// </summary>
	public unsafe static partial class _
	{
		// Signature, CallingConventionConverter_GetStubs, [fwd] [return] [Mcg.CodeGen.VoidReturnMarshaller] void__void, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.TypeLoader, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.Runtime.TypeLoader.CallConverterThunk", "CallingConventionConverter_GetStubs")]
		public static void CallingConventionConverter_GetStubs(
					out global::System.IntPtr returnVoidStub, 
					out global::System.IntPtr returnIntegerStub, 
					out global::System.IntPtr commonStub, 
					out global::System.IntPtr returnFloatingPointReturn4Thunk, 
					out global::System.IntPtr returnFloatingPointReturn8Thunk)
		{
			// Setup
			global::System.IntPtr unsafe_returnVoidStub;
			global::System.IntPtr unsafe_returnIntegerStub;
			global::System.IntPtr unsafe_commonStub;
			global::System.IntPtr unsafe_returnFloatingPointReturn4Thunk;
			global::System.IntPtr unsafe_returnFloatingPointReturn8Thunk;
			// Marshalling
			// Call to native method
			global::McgInterop.__PInvokes.CallingConventionConverter_GetStubs(
								&(unsafe_returnVoidStub), 
								&(unsafe_returnIntegerStub), 
								&(unsafe_commonStub), 
								&(unsafe_returnFloatingPointReturn4Thunk), 
								&(unsafe_returnFloatingPointReturn8Thunk)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			returnFloatingPointReturn8Thunk = unsafe_returnFloatingPointReturn8Thunk;
			returnFloatingPointReturn4Thunk = unsafe_returnFloatingPointReturn4Thunk;
			commonStub = unsafe_commonStub;
			returnIntegerStub = unsafe_returnIntegerStub;
			returnVoidStub = unsafe_returnVoidStub;
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-errorhandling-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_errorhandling_l1_1_0_dll
	{
		// Signature, GetLastError, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Runtime.Extensions, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "GetLastError")]
		public static int GetLastError()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes.GetLastError();
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_l1_1_0_dll
	{
		// Signature, RoInitialize, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "RoInitialize")]
		public static int RoInitialize(uint initType)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_winrt_l1_1_0_dll_PInvokes.RoInitialize(initType);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'ws2_32.dll'
	/// </summary>
	public unsafe static partial class ws2_32_dll
	{
		// Signature, getsockname, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getsockname")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives getsockname(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					byte[] socketAddress, 
					ref int socketAddressSize)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_socketAddress;
			int unsafe_socketAddressSize;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_socketAddress = global::McgInterop.McgCoreHelpers.GetArrayForCompat(socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				unsafe_socketAddressSize = socketAddressSize;
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.getsockname(
									socketHandle.DangerousGetHandle(), 
									unsafe_socketAddress, 
									&(unsafe_socketAddressSize)
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				socketAddressSize = unsafe_socketAddressSize;
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, getsockopt, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives getsockopt(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					out int optionValue, 
					ref int optionLength)
		{
			// Setup
			bool addRefed = false;
			int unsafe_optionValue;
			int unsafe_optionLength;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_optionLength = optionLength;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.getsockopt(
								socketHandle.DangerousGetHandle(), 
								optionLevel, 
								optionName, 
								&(unsafe_optionValue), 
								&(unsafe_optionLength)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			optionLength = unsafe_optionLength;
			optionValue = unsafe_optionValue;
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WSARecv, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSARecv")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSARecv(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					ref global::System.Net.Sockets.WSABuffer__System_Net_Sockets buffer, 
					int bufferCount, 
					out int bytesTransferred, 
					ref global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.Runtime.InteropServices.SafeHandle overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			bool addRefed = false;
			global::System.Net.Sockets.WSABuffer__System_Net_Sockets unsafe_buffer;
			int unsafe_bytesTransferred;
			global::System.Net.Sockets.SocketFlags__System_Net_Sockets unsafe_socketFlags;
			bool addRefed_1 = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_buffer = buffer;
			unsafe_socketFlags = socketFlags;
			overlapped.DangerousAddRef(ref addRefed_1);
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSARecv(
								socketHandle.DangerousGetHandle(), 
								&(unsafe_buffer), 
								bufferCount, 
								&(unsafe_bytesTransferred), 
								&(unsafe_socketFlags), 
								overlapped.DangerousGetHandle(), 
								completionRoutine
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed_1)
				overlapped.DangerousRelease();
			socketFlags = unsafe_socketFlags;
			bytesTransferred = unsafe_bytesTransferred;
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WSARecv__0, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [out] [Mcg.CodeGen.ArrayMarshaller] rg_System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSARecv")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSARecv__0(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets[] buffers, 
					int bufferCount, 
					out int bytesTransferred, 
					ref global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.Runtime.InteropServices.SafeHandle overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			bool addRefed = false;
			global::System.Net.Sockets.WSABuffer__System_Net_Sockets* unsafe_buffers = default(global::System.Net.Sockets.WSABuffer__System_Net_Sockets*);
			int unsafe_bytesTransferred;
			global::System.Net.Sockets.SocketFlags__System_Net_Sockets unsafe_socketFlags;
			bool addRefed_1 = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			try
			{
				// Marshalling
				socketHandle.DangerousAddRef(ref addRefed);
				if (buffers == null)
					unsafe_buffers = null;
				else
				{
					if (buffers != null)
						unsafe_buffers = (global::System.Net.Sockets.WSABuffer__System_Net_Sockets*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(((global::System.IntPtr)checked(buffers.Length * sizeof(global::System.Net.Sockets.WSABuffer__System_Net_Sockets))));
					if (buffers != null)
						for (uint mcgIdx = 0; (mcgIdx < buffers.Length); mcgIdx++)
						{
							// [fwd] [in] [optional] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets buffers
							unsafe_buffers[mcgIdx] = buffers[mcgIdx];
						}
				}
				unsafe_socketFlags = socketFlags;
				overlapped.DangerousAddRef(ref addRefed_1);
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSARecv__0(
									socketHandle.DangerousGetHandle(), 
									unsafe_buffers, 
									bufferCount, 
									&(unsafe_bytesTransferred), 
									&(unsafe_socketFlags), 
									overlapped.DangerousGetHandle(), 
									completionRoutine
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (addRefed_1)
					overlapped.DangerousRelease();
				socketFlags = unsafe_socketFlags;
				bytesTransferred = unsafe_bytesTransferred;
				if (buffers != null)
					for (uint mcgIdx_1 = 0; (mcgIdx_1 < buffers.Length); mcgIdx_1++)
					{
						// [fwd] [optional] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets buffers
						buffers[mcgIdx_1] = unsafe_buffers[mcgIdx_1];
					}
				if (addRefed)
					socketHandle.DangerousRelease();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_buffers);
			}
		}

		// Signature, WSASend, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASend")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSASend(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					ref global::System.Net.Sockets.WSABuffer__System_Net_Sockets buffer, 
					int bufferCount, 
					out int bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.Runtime.InteropServices.SafeHandle overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			bool addRefed = false;
			global::System.Net.Sockets.WSABuffer__System_Net_Sockets unsafe_buffer;
			int unsafe_bytesTransferred;
			bool addRefed_1 = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_buffer = buffer;
			overlapped.DangerousAddRef(ref addRefed_1);
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSASend(
								socketHandle.DangerousGetHandle(), 
								&(unsafe_buffer), 
								bufferCount, 
								&(unsafe_bytesTransferred), 
								socketFlags, 
								overlapped.DangerousGetHandle(), 
								completionRoutine
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed_1)
				overlapped.DangerousRelease();
			bytesTransferred = unsafe_bytesTransferred;
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WSASend__0, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.ArrayMarshaller] rg_System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASend")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSASend__0(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets[] buffersArray, 
					int bufferCount, 
					out int bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.Runtime.InteropServices.SafeHandle overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			bool addRefed = false;
			global::System.Net.Sockets.WSABuffer__System_Net_Sockets* unsafe_buffersArray = default(global::System.Net.Sockets.WSABuffer__System_Net_Sockets*);
			int unsafe_bytesTransferred;
			bool addRefed_1 = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			try
			{
				// Marshalling
				socketHandle.DangerousAddRef(ref addRefed);
				if (buffersArray == null)
					unsafe_buffersArray = null;
				else
				{
					if (buffersArray != null)
						unsafe_buffersArray = (global::System.Net.Sockets.WSABuffer__System_Net_Sockets*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(((global::System.IntPtr)checked(buffersArray.Length * sizeof(global::System.Net.Sockets.WSABuffer__System_Net_Sockets))));
					if (buffersArray != null)
						for (uint mcgIdx = 0; (mcgIdx < buffersArray.Length); mcgIdx++)
						{
							// [fwd] [in] [optional] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets buffersArray
							unsafe_buffersArray[mcgIdx] = buffersArray[mcgIdx];
						}
				}
				overlapped.DangerousAddRef(ref addRefed_1);
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSASend__0(
									socketHandle.DangerousGetHandle(), 
									unsafe_buffersArray, 
									bufferCount, 
									&(unsafe_bytesTransferred), 
									socketFlags, 
									overlapped.DangerousGetHandle(), 
									completionRoutine
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (addRefed_1)
					overlapped.DangerousRelease();
				bytesTransferred = unsafe_bytesTransferred;
				if (addRefed)
					socketHandle.DangerousRelease();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_buffersArray);
			}
		}

		// Signature, getpeername, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getpeername")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives getpeername(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					byte[] socketAddress, 
					ref int socketAddressSize)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_socketAddress;
			int unsafe_socketAddressSize;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_socketAddress = global::McgInterop.McgCoreHelpers.GetArrayForCompat(socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				unsafe_socketAddressSize = socketAddressSize;
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.getpeername(
									socketHandle.DangerousGetHandle(), 
									unsafe_socketAddress, 
									&(unsafe_socketAddressSize)
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				socketAddressSize = unsafe_socketAddressSize;
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, shutdown, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "shutdown")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives shutdown(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					int how)
		{
			// Setup
			bool addRefed = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.shutdown(
								socketHandle.DangerousGetHandle(), 
								how
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WSARecvFrom, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSARecvFrom")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSARecvFrom(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					ref global::System.Net.Sockets.WSABuffer__System_Net_Sockets buffer, 
					int bufferCount, 
					out int bytesTransferred, 
					ref global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.IntPtr socketAddressPointer, 
					global::System.IntPtr socketAddressSizePointer, 
					global::System.Runtime.InteropServices.SafeHandle overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			bool addRefed = false;
			global::System.Net.Sockets.WSABuffer__System_Net_Sockets unsafe_buffer;
			int unsafe_bytesTransferred;
			global::System.Net.Sockets.SocketFlags__System_Net_Sockets unsafe_socketFlags;
			bool addRefed_1 = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_buffer = buffer;
			unsafe_socketFlags = socketFlags;
			overlapped.DangerousAddRef(ref addRefed_1);
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSARecvFrom(
								socketHandle.DangerousGetHandle(), 
								&(unsafe_buffer), 
								bufferCount, 
								&(unsafe_bytesTransferred), 
								&(unsafe_socketFlags), 
								socketAddressPointer, 
								socketAddressSizePointer, 
								overlapped.DangerousGetHandle(), 
								completionRoutine
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed_1)
				overlapped.DangerousRelease();
			socketFlags = unsafe_socketFlags;
			bytesTransferred = unsafe_bytesTransferred;
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WSARecvFrom__0, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [out] [Mcg.CodeGen.ArrayMarshaller] rg_System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeNativeOverlapped__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSARecvFrom")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSARecvFrom__0(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets[] buffers, 
					int bufferCount, 
					out int bytesTransferred, 
					ref global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.IntPtr socketAddressPointer, 
					global::System.IntPtr socketAddressSizePointer, 
					global::System.Net.Sockets.SafeNativeOverlapped__System_Net_Sockets overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			bool addRefed = false;
			global::System.Net.Sockets.WSABuffer__System_Net_Sockets* unsafe_buffers = default(global::System.Net.Sockets.WSABuffer__System_Net_Sockets*);
			int unsafe_bytesTransferred;
			global::System.Net.Sockets.SocketFlags__System_Net_Sockets unsafe_socketFlags;
			bool addRefed_1 = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			try
			{
				// Marshalling
				socketHandle.DangerousAddRef(ref addRefed);
				if (buffers == null)
					unsafe_buffers = null;
				else
				{
					if (buffers != null)
						unsafe_buffers = (global::System.Net.Sockets.WSABuffer__System_Net_Sockets*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(((global::System.IntPtr)checked(buffers.Length * sizeof(global::System.Net.Sockets.WSABuffer__System_Net_Sockets))));
					if (buffers != null)
						for (uint mcgIdx = 0; (mcgIdx < buffers.Length); mcgIdx++)
						{
							// [fwd] [in] [optional] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets buffers
							unsafe_buffers[mcgIdx] = buffers[mcgIdx];
						}
				}
				unsafe_socketFlags = socketFlags;
				overlapped.DangerousAddRef(ref addRefed_1);
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSARecvFrom__0(
									socketHandle.DangerousGetHandle(), 
									unsafe_buffers, 
									bufferCount, 
									&(unsafe_bytesTransferred), 
									&(unsafe_socketFlags), 
									socketAddressPointer, 
									socketAddressSizePointer, 
									overlapped.DangerousGetHandle(), 
									completionRoutine
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (addRefed_1)
					overlapped.DangerousRelease();
				socketFlags = unsafe_socketFlags;
				bytesTransferred = unsafe_bytesTransferred;
				if (buffers != null)
					for (uint mcgIdx_1 = 0; (mcgIdx_1 < buffers.Length); mcgIdx_1++)
					{
						// [fwd] [optional] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets buffers
						buffers[mcgIdx_1] = unsafe_buffers[mcgIdx_1];
					}
				if (addRefed)
					socketHandle.DangerousRelease();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_buffers);
			}
		}

		// Signature, WSASendTo, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASendTo")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSASendTo(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					ref global::System.Net.Sockets.WSABuffer__System_Net_Sockets buffer, 
					int bufferCount, 
					out int bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.IntPtr socketAddress, 
					int socketAddressSize, 
					global::System.Runtime.InteropServices.SafeHandle overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			bool addRefed = false;
			global::System.Net.Sockets.WSABuffer__System_Net_Sockets unsafe_buffer;
			int unsafe_bytesTransferred;
			bool addRefed_1 = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_buffer = buffer;
			overlapped.DangerousAddRef(ref addRefed_1);
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSASendTo(
								socketHandle.DangerousGetHandle(), 
								&(unsafe_buffer), 
								bufferCount, 
								&(unsafe_bytesTransferred), 
								socketFlags, 
								socketAddress, 
								socketAddressSize, 
								overlapped.DangerousGetHandle(), 
								completionRoutine
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed_1)
				overlapped.DangerousRelease();
			bytesTransferred = unsafe_bytesTransferred;
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WSASendTo__0, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.ArrayMarshaller] rg_System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeNativeOverlapped__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASendTo")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSASendTo__0(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets[] buffersArray, 
					int bufferCount, 
					out int bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.IntPtr socketAddress, 
					int socketAddressSize, 
					global::System.Net.Sockets.SafeNativeOverlapped__System_Net_Sockets overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			bool addRefed = false;
			global::System.Net.Sockets.WSABuffer__System_Net_Sockets* unsafe_buffersArray = default(global::System.Net.Sockets.WSABuffer__System_Net_Sockets*);
			int unsafe_bytesTransferred;
			bool addRefed_1 = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			try
			{
				// Marshalling
				socketHandle.DangerousAddRef(ref addRefed);
				if (buffersArray == null)
					unsafe_buffersArray = null;
				else
				{
					if (buffersArray != null)
						unsafe_buffersArray = (global::System.Net.Sockets.WSABuffer__System_Net_Sockets*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(((global::System.IntPtr)checked(buffersArray.Length * sizeof(global::System.Net.Sockets.WSABuffer__System_Net_Sockets))));
					if (buffersArray != null)
						for (uint mcgIdx = 0; (mcgIdx < buffersArray.Length); mcgIdx++)
						{
							// [fwd] [in] [optional] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets buffersArray
							unsafe_buffersArray[mcgIdx] = buffersArray[mcgIdx];
						}
				}
				overlapped.DangerousAddRef(ref addRefed_1);
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSASendTo__0(
									socketHandle.DangerousGetHandle(), 
									unsafe_buffersArray, 
									bufferCount, 
									&(unsafe_bytesTransferred), 
									socketFlags, 
									socketAddress, 
									socketAddressSize, 
									overlapped.DangerousGetHandle(), 
									completionRoutine
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (addRefed_1)
					overlapped.DangerousRelease();
				bytesTransferred = unsafe_bytesTransferred;
				if (addRefed)
					socketHandle.DangerousRelease();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_buffersArray);
			}
		}

		// Signature, sendto, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "sendto")]
		public static int sendto(
					global::System.IntPtr socketHandle, 
					byte* pinnedBuffer, 
					int len, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					byte[] socketAddress, 
					int socketAddressSize)
		{
			// Setup
			byte* unsafe_socketAddress;
			int unsafe___value;
			// Marshalling
			fixed (byte* pinned_socketAddress = global::McgInterop.McgCoreHelpers.GetArrayForCompat(socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.sendto(
									socketHandle, 
									((byte*)pinnedBuffer), 
									len, 
									socketFlags, 
									unsafe_socketAddress, 
									socketAddressSize
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, listen, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "listen")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives listen(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					int backlog)
		{
			// Setup
			bool addRefed = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.listen(
								socketHandle.DangerousGetHandle(), 
								backlog
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, recv, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "recv")]
		public static int recv(
					global::System.IntPtr socketHandle, 
					byte* pinnedBuffer, 
					int len, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.recv(
								socketHandle, 
								((byte*)pinnedBuffer), 
								len, 
								socketFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, send, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "send")]
		public static int send(
					global::System.IntPtr socketHandle, 
					byte* pinnedBuffer, 
					int len, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.send(
								socketHandle, 
								((byte*)pinnedBuffer), 
								len, 
								socketFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, WSASend_Blocking, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.ArrayMarshaller] rg_System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASend_Blocking")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSASend_Blocking(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets[] buffersArray, 
					int bufferCount, 
					out int bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.Runtime.InteropServices.SafeHandle overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			global::System.Net.Sockets.WSABuffer__System_Net_Sockets* unsafe_buffersArray = default(global::System.Net.Sockets.WSABuffer__System_Net_Sockets*);
			int unsafe_bytesTransferred;
			bool addRefed = false;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			try
			{
				// Marshalling
				if (buffersArray == null)
					unsafe_buffersArray = null;
				else
				{
					if (buffersArray != null)
						unsafe_buffersArray = (global::System.Net.Sockets.WSABuffer__System_Net_Sockets*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(((global::System.IntPtr)checked(buffersArray.Length * sizeof(global::System.Net.Sockets.WSABuffer__System_Net_Sockets))));
					if (buffersArray != null)
						for (uint mcgIdx = 0; (mcgIdx < buffersArray.Length); mcgIdx++)
						{
							// [fwd] [in] [optional] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_WSABuffer__System_Net_Sockets__System_Net_Sockets__WSABuffer__System_Net_Sockets buffersArray
							unsafe_buffersArray[mcgIdx] = buffersArray[mcgIdx];
						}
				}
				overlapped.DangerousAddRef(ref addRefed);
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSASend_Blocking(
									socketHandle, 
									unsafe_buffersArray, 
									bufferCount, 
									&(unsafe_bytesTransferred), 
									socketFlags, 
									overlapped.DangerousGetHandle(), 
									completionRoutine
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (addRefed)
					overlapped.DangerousRelease();
				bytesTransferred = unsafe_bytesTransferred;
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_buffersArray);
			}
		}

		// Signature, WSAStartup, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] short__short, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.StructMarshaller] Interop_Winsock_WSAData__System_Net_NameResolution____Interop_Winsock_WSAData__System_Net_NameResolution, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSAStartup")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSAStartup(
					short wVersionRequested, 
					out global::Interop_Winsock_WSAData__System_Net_NameResolution lpWSAData)
		{
			// Setup
			global::Interop_Winsock_WSAData__System_Net_NameResolution__Impl.UnsafeType unsafe_lpWSAData = default(global::Interop_Winsock_WSAData__System_Net_NameResolution__Impl.UnsafeType);
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			unsafe_lpWSAData = default(global::Interop_Winsock_WSAData__System_Net_NameResolution__Impl.UnsafeType);
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSAStartup(
								wVersionRequested, 
								&(unsafe_lpWSAData)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::Interop_Winsock_WSAData__System_Net_NameResolution__Impl.Marshal__UnsafeToSafe(
								ref unsafe_lpWSAData, 
								out lpWSAData
							);
			// Return
			return unsafe___value;
		}

		// Signature, select, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, [fwd] [in] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, [fwd] [in] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Interop_Winsock_TimeValue__System_Net_Sockets____Interop_Winsock_TimeValue__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "select")]
		public static int select(
					int ignoredParameter, 
					global::System.IntPtr[] readfds, 
					global::System.IntPtr[] writefds, 
					global::System.IntPtr[] exceptfds, 
					ref global::Interop_Winsock_TimeValue__System_Net_Sockets timeout)
		{
			// Setup
			global::System.IntPtr* unsafe_readfds;
			global::System.IntPtr* unsafe_writefds;
			global::System.IntPtr* unsafe_exceptfds;
			global::Interop_Winsock_TimeValue__System_Net_Sockets unsafe_timeout;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_readfds = global::McgInterop.McgCoreHelpers.GetArrayForCompat(readfds))
			{
				unsafe_readfds = (global::System.IntPtr*)pinned_readfds;
				fixed (global::System.IntPtr* pinned_writefds = global::McgInterop.McgCoreHelpers.GetArrayForCompat(writefds))
				{
					unsafe_writefds = (global::System.IntPtr*)pinned_writefds;
					fixed (global::System.IntPtr* pinned_exceptfds = global::McgInterop.McgCoreHelpers.GetArrayForCompat(exceptfds))
					{
						unsafe_exceptfds = (global::System.IntPtr*)pinned_exceptfds;
						unsafe_timeout = timeout;
						// Call to native method
						unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.select(
											ignoredParameter, 
											unsafe_readfds, 
											unsafe_writefds, 
											unsafe_exceptfds, 
											&(unsafe_timeout)
										);
						global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, select__0, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, [fwd] [in] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, [fwd] [in] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_System_IntPtr____w64 int *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "select")]
		public static int select__0(
					int ignoredParameter, 
					global::System.IntPtr[] readfds, 
					global::System.IntPtr[] writefds, 
					global::System.IntPtr[] exceptfds, 
					global::System.IntPtr nullTimeout)
		{
			// Setup
			global::System.IntPtr* unsafe_readfds;
			global::System.IntPtr* unsafe_writefds;
			global::System.IntPtr* unsafe_exceptfds;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_readfds = global::McgInterop.McgCoreHelpers.GetArrayForCompat(readfds))
			{
				unsafe_readfds = (global::System.IntPtr*)pinned_readfds;
				fixed (global::System.IntPtr* pinned_writefds = global::McgInterop.McgCoreHelpers.GetArrayForCompat(writefds))
				{
					unsafe_writefds = (global::System.IntPtr*)pinned_writefds;
					fixed (global::System.IntPtr* pinned_exceptfds = global::McgInterop.McgCoreHelpers.GetArrayForCompat(exceptfds))
					{
						unsafe_exceptfds = (global::System.IntPtr*)pinned_exceptfds;
						// Call to native method
						unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.select__0(
											ignoredParameter, 
											unsafe_readfds, 
											unsafe_writefds, 
											unsafe_exceptfds, 
											nullTimeout
										);
						global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, ioctlsocket, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "ioctlsocket")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives ioctlsocket(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					int cmd, 
					ref int argp)
		{
			// Setup
			bool addRefed = false;
			int unsafe_argp;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_argp = argp;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.ioctlsocket(
								socketHandle.DangerousGetHandle(), 
								cmd, 
								&(unsafe_argp)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			argp = unsafe_argp;
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, bind, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "bind")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives bind(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					byte[] socketAddress, 
					int socketAddressSize)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_socketAddress;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_socketAddress = global::McgInterop.McgCoreHelpers.GetArrayForCompat(socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.bind(
									socketHandle.DangerousGetHandle(), 
									unsafe_socketAddress, 
									socketAddressSize
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					ref int optionValue, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			int unsafe_optionValue;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_optionValue = optionValue;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.setsockopt(
								socketHandle.DangerousGetHandle(), 
								optionLevel, 
								optionName, 
								&(unsafe_optionValue), 
								optionLength
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, getsockopt__0, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Interop_Winsock_Linger__System_Net_Sockets____Interop_Winsock_Linger__System_Net_Sockets, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives getsockopt__0(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					out global::Interop_Winsock_Linger__System_Net_Sockets optionValue, 
					ref int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::Interop_Winsock_Linger__System_Net_Sockets unsafe_optionValue;
			int unsafe_optionLength;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_optionLength = optionLength;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.getsockopt__0(
								socketHandle.DangerousGetHandle(), 
								optionLevel, 
								optionName, 
								&(unsafe_optionValue), 
								&(unsafe_optionLength)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			optionLength = unsafe_optionLength;
			optionValue = unsafe_optionValue;
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, getsockopt__1, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Interop_Winsock_IPMulticastRequest__System_Net_Sockets____Interop_Winsock_IPMulticastRequest__System_Net_Sockets, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives getsockopt__1(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					out global::Interop_Winsock_IPMulticastRequest__System_Net_Sockets optionValue, 
					ref int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::Interop_Winsock_IPMulticastRequest__System_Net_Sockets unsafe_optionValue;
			int unsafe_optionLength;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_optionLength = optionLength;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.getsockopt__1(
								socketHandle.DangerousGetHandle(), 
								optionLevel, 
								optionName, 
								&(unsafe_optionValue), 
								&(unsafe_optionLength)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			optionLength = unsafe_optionLength;
			optionValue = unsafe_optionValue;
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, getsockopt__2, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.StructMarshaller] Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets____Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives getsockopt__2(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					out global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets optionValue, 
					ref int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType unsafe_optionValue = default(global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType);
			int unsafe_optionLength;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_optionValue = default(global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType);
			unsafe_optionLength = optionLength;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.getsockopt__2(
								socketHandle.DangerousGetHandle(), 
								optionLevel, 
								optionName, 
								&(unsafe_optionValue), 
								&(unsafe_optionLength)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			optionLength = unsafe_optionLength;
			global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.Marshal__UnsafeToSafe(
								ref unsafe_optionValue, 
								out optionValue
							);
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WSAConnect, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSAConnect")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSAConnect(
					global::System.IntPtr socketHandle, 
					byte[] socketAddress, 
					int socketAddressSize, 
					global::System.IntPtr inBuffer, 
					global::System.IntPtr outBuffer, 
					global::System.IntPtr sQOS, 
					global::System.IntPtr gQOS)
		{
			// Setup
			byte* unsafe_socketAddress;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			fixed (byte* pinned_socketAddress = global::McgInterop.McgCoreHelpers.GetArrayForCompat(socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSAConnect(
									socketHandle, 
									unsafe_socketAddress, 
									socketAddressSize, 
									inBuffer, 
									outBuffer, 
									sQOS, 
									gQOS
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt__0, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Interop_Winsock_Linger__System_Net_Sockets____Interop_Winsock_Linger__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__0(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					ref global::Interop_Winsock_Linger__System_Net_Sockets linger, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::Interop_Winsock_Linger__System_Net_Sockets unsafe_linger;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_linger = linger;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.setsockopt__0(
								socketHandle.DangerousGetHandle(), 
								optionLevel, 
								optionName, 
								&(unsafe_linger), 
								optionLength
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt__1, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Interop_Winsock_IPMulticastRequest__System_Net_Sockets____Interop_Winsock_IPMulticastRequest__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__1(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					ref global::Interop_Winsock_IPMulticastRequest__System_Net_Sockets mreq, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::Interop_Winsock_IPMulticastRequest__System_Net_Sockets unsafe_mreq;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_mreq = mreq;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.setsockopt__1(
								socketHandle.DangerousGetHandle(), 
								optionLevel, 
								optionName, 
								&(unsafe_mreq), 
								optionLength
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt__2, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.StructMarshaller] Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets____Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__2(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					ref global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets mreq, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType unsafe_mreq = default(global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType);
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.Marshal__SafeToUnsafe(
								ref mreq, 
								out unsafe_mreq
							);
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.setsockopt__2(
								socketHandle.DangerousGetHandle(), 
								optionLevel, 
								optionName, 
								&(unsafe_mreq), 
								optionLength
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WSAGetOverlappedResult, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSAGetOverlappedResult")]
		public static bool WSAGetOverlappedResult(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Runtime.InteropServices.SafeHandle overlapped, 
					out uint bytesTransferred, 
					bool wait, 
					out global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			uint unsafe_bytesTransferred;
			global::System.Net.Sockets.SocketFlags__System_Net_Sockets unsafe_socketFlags;
			int unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			overlapped.DangerousAddRef(ref addRefed_1);
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSAGetOverlappedResult(
								socketHandle.DangerousGetHandle(), 
								overlapped.DangerousGetHandle(), 
								&(unsafe_bytesTransferred), 
								(wait ? 1 : 0), 
								&(unsafe_socketFlags)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			socketFlags = unsafe_socketFlags;
			bytesTransferred = unsafe_bytesTransferred;
			if (addRefed_1)
				overlapped.DangerousRelease();
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, WSASocketW, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_AddressFamily__System_Net_Primitives__AddressFamily__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketType__System_Net_Sockets__SocketType__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_ProtocolType__System_Net_Sockets__ProtocolType__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Interop_Winsock_SocketConstructorFlags__System_Net_Sockets__Interop_Winsock_SocketConstructorFlags__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASocketW")]
		public static global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets WSASocketW(
					global::System.Net.Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System.Net.Sockets.SocketType__System_Net_Sockets socketType, 
					global::System.Net.Sockets.ProtocolType__System_Net_Sockets protocolType, 
					global::System.IntPtr protocolInfo, 
					uint group, 
					global::Interop_Winsock_SocketConstructorFlags__System_Net_Sockets flags)
		{
			// Setup
			global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets();
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSASocketW(
								addressFamily, 
								socketType, 
								protocolType, 
								protocolInfo, 
								group, 
								flags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, accept, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "accept")]
		public static global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets accept(
					global::System.IntPtr socketHandle, 
					byte[] socketAddress, 
					ref int socketAddressSize)
		{
			// Setup
			byte* unsafe_socketAddress;
			int unsafe_socketAddressSize;
			global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			fixed (byte* pinned_socketAddress = global::McgInterop.McgCoreHelpers.GetArrayForCompat(socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				unsafe_socketAddressSize = socketAddressSize;
				__value = new global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets();
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.accept(
									socketHandle, 
									unsafe_socketAddress, 
									&(unsafe_socketAddressSize)
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									__value, 
									unsafe___value
								);
				socketAddressSize = unsafe_socketAddressSize;
			}
			// Return
			return __value;
		}

		// Signature, gethostname, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "gethostname")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives gethostname(
					global::System.Text.StringBuilder hostName, 
					int bufferLength)
		{
			// Setup
			byte* unsafe_hostName = default(byte*);
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			try
			{
				// Marshalling
				if (hostName == null)
					unsafe_hostName = null;
				else
				{
					unsafe_hostName = (byte*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(hostName.Capacity * global::System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize 
										+ 2)));
					if (unsafe_hostName == null)
						throw new global::System.OutOfMemoryException();
				}
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.gethostname(
									unsafe_hostName, 
									bufferLength
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (hostName != null)
					global::System.Runtime.InteropServices.McgMarshal.AnsiStringToStringBuilder(
										unsafe_hostName, 
										hostName
									);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_hostName != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_hostName);
			}
		}

		// Signature, WSASocketW__0, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_AddressFamily__System_Net_Primitives__AddressFamily__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketType__System_Net_Sockets__SocketType__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASocketW")]
		public static global::System.IntPtr WSASocketW__0(
					global::System.Net.Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System.Net.Sockets.SocketType__System_Net_Sockets socketType, 
					int protocolType, 
					global::System.IntPtr protocolInfo, 
					int group, 
					int flags)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSASocketW__0(
								addressFamily, 
								socketType, 
								protocolType, 
								protocolInfo, 
								group, 
								flags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, closesocket, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "closesocket")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives closesocket(global::System.IntPtr socketHandle)
		{
			// Setup
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.closesocket(socketHandle);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt__3, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__3(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					ref global::System.IntPtr pointer, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_pointer;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_pointer = pointer;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.setsockopt__3(
								socketHandle.DangerousGetHandle(), 
								optionLevel, 
								optionName, 
								&(unsafe_pointer), 
								optionLength
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt__4, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__4(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					byte[] optionValue, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_optionValue;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_optionValue = global::McgInterop.McgCoreHelpers.GetArrayForCompat(optionValue))
			{
				unsafe_optionValue = (byte*)pinned_optionValue;
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.setsockopt__4(
									socketHandle.DangerousGetHandle(), 
									optionLevel, 
									optionName, 
									unsafe_optionValue, 
									optionLength
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, ioctlsocket__0, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "ioctlsocket")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives ioctlsocket__0(
					global::System.IntPtr handle, 
					int cmd, 
					ref int argp)
		{
			// Setup
			int unsafe_argp;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			unsafe_argp = argp;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.ioctlsocket__0(
								handle, 
								cmd, 
								&(unsafe_argp)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			argp = unsafe_argp;
			// Return
			return unsafe___value;
		}

		// Signature, WSAEventSelect, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Interop_Winsock_AsyncEventBits__System_Net_Sockets__Interop_Winsock_AsyncEventBits__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSAEventSelect")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSAEventSelect(
					global::System.IntPtr handle, 
					global::System.IntPtr Event, 
					global::Interop_Winsock_AsyncEventBits__System_Net_Sockets NetworkEvents)
		{
			// Setup
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSAEventSelect(
								handle, 
								Event, 
								NetworkEvents
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt__5, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Interop_Winsock_Linger__System_Net_Sockets____Interop_Winsock_Linger__System_Net_Sockets, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__5(
					global::System.IntPtr handle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					ref global::Interop_Winsock_Linger__System_Net_Sockets linger, 
					int optionLength)
		{
			// Setup
			global::Interop_Winsock_Linger__System_Net_Sockets unsafe_linger;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			unsafe_linger = linger;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.setsockopt__5(
								handle, 
								optionLevel, 
								optionName, 
								&(unsafe_linger), 
								optionLength
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, WSAIoctl, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] System_Guid__System.Guid, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSAIoctl")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives WSAIoctl(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					int ioControlCode, 
					ref global::System.Guid guid, 
					int guidSize, 
					out global::System.IntPtr funcPtr, 
					int funcPtrSize, 
					out int bytesTransferred, 
					global::System.IntPtr shouldBeNull, 
					global::System.IntPtr shouldBeNull2)
		{
			// Setup
			bool addRefed = false;
			global::System.Guid unsafe_guid;
			global::System.IntPtr unsafe_funcPtr;
			int unsafe_bytesTransferred;
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_guid = guid;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSAIoctl(
								socketHandle.DangerousGetHandle(), 
								ioControlCode, 
								&(unsafe_guid), 
								guidSize, 
								&(unsafe_funcPtr), 
								funcPtrSize, 
								&(unsafe_bytesTransferred), 
								shouldBeNull, 
								shouldBeNull2
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			bytesTransferred = unsafe_bytesTransferred;
			funcPtr = unsafe_funcPtr;
			guid = unsafe_guid;
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, GetNameInfoW, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "GetNameInfoW")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives GetNameInfoW(
					byte[] sa, 
					int salen, 
					global::System.Text.StringBuilder host, 
					int hostlen, 
					global::System.Text.StringBuilder serv, 
					int servlen, 
					int flags)
		{
			// Setup
			byte* unsafe_sa;
			ushort* unsafe_host = default(ushort*);
			ushort* unsafe_serv = default(ushort*);
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			try
			{
				// Marshalling
				fixed (byte* pinned_sa = global::McgInterop.McgCoreHelpers.GetArrayForCompat(sa))
				{
					unsafe_sa = (byte*)pinned_sa;
					if (host == null)
						unsafe_host = null;
					else
					{
						unsafe_host = (ushort*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(host.Capacity * 2 
											+ 2)));
						if (unsafe_host == null)
							throw new global::System.OutOfMemoryException();
					}
					if (serv == null)
						unsafe_serv = null;
					else
					{
						unsafe_serv = (ushort*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(serv.Capacity * 2 
											+ 2)));
						if (unsafe_serv == null)
							throw new global::System.OutOfMemoryException();
					}
					// Call to native method
					unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.GetNameInfoW(
										unsafe_sa, 
										salen, 
										unsafe_host, 
										hostlen, 
										unsafe_serv, 
										servlen, 
										flags
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					if (serv != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_serv, 
											serv
										);
					if (host != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_host, 
											host
										);
				}
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_host != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_host);
				if (unsafe_serv != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_serv);
			}
		}

		// Signature, gethostbyaddr, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_ProtocolFamily__System_Net_NameResolution__ProtocolFamily__System_Net_NameResolution, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "gethostbyaddr")]
		public static global::System.IntPtr gethostbyaddr(
					ref int addr, 
					int len, 
					global::System.Net.Sockets.ProtocolFamily__System_Net_NameResolution type)
		{
			// Setup
			int unsafe_addr;
			global::System.IntPtr unsafe___value;
			// Marshalling
			unsafe_addr = addr;
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.gethostbyaddr(
								&(unsafe_addr), 
								len, 
								type
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, gethostbyname, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.AnsiStringMarshaller] string__unsigned char *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "gethostbyname")]
		public static global::System.IntPtr gethostbyname(string host)
		{
			// Setup
			byte* unsafe_host = default(byte*);
			global::System.IntPtr unsafe___value;
			try
			{
				// Marshalling
				unsafe_host = global::System.Runtime.InteropServices.McgMarshal.StringToAnsiString(host, false, true);
				// Call to native method
				unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.gethostbyname(unsafe_host);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_host);
			}
		}

		// Signature, GetAddrInfoW, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] System_Net_Sockets_AddressInfo__System_Net_NameResolution__System_Net_Sockets__AddressInfo__System_Net_NameResolution, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] System_Net_Sockets_SafeFreeAddrInfo__System_Net_NameResolution____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "GetAddrInfoW")]
		public static int GetAddrInfoW(
					string nodename, 
					string servicename, 
					ref global::System.Net.Sockets.AddressInfo__System_Net_NameResolution hints, 
					out global::System.Net.Sockets.SafeFreeAddrInfo__System_Net_NameResolution handle)
		{
			// Setup
			ushort* unsafe_nodename = default(ushort*);
			ushort* unsafe_servicename = default(ushort*);
			global::System.Net.Sockets.AddressInfo__System_Net_NameResolution unsafe_hints;
			global::System.IntPtr unsafe_handle;
			int unsafe___value;
			// Marshalling
			fixed (char* pinned_nodename = nodename)
			{
				unsafe_nodename = (ushort*)pinned_nodename;
				fixed (char* pinned_servicename = servicename)
				{
					unsafe_servicename = (ushort*)pinned_servicename;
					unsafe_hints = hints;
					handle = new global::System.Net.Sockets.SafeFreeAddrInfo__System_Net_NameResolution();
					unsafe_handle = handle.DangerousGetHandle();
					// Call to native method
					unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.GetAddrInfoW(
										unsafe_nodename, 
										unsafe_servicename, 
										&(unsafe_hints), 
										&(unsafe_handle)
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
										handle, 
										unsafe_handle
									);
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, WSASocketW__1, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_AddressFamily__System_Net_Primitives__AddressFamily__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Net_Internals_SocketType__System_Net_NameResolution__SocketType__System_Net_NameResolution, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASocketW")]
		public static global::System.IntPtr WSASocketW__1(
					global::System.Net.Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System.Net.Internals.SocketType__System_Net_NameResolution socketType, 
					int protocolType, 
					global::System.IntPtr protocolInfo, 
					int group, 
					int flags)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.WSASocketW__1(
								addressFamily, 
								socketType, 
								protocolType, 
								protocolInfo, 
								group, 
								flags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, closesocket__0, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "closesocket")]
		public static global::System.Net.Sockets.SocketError__System_Net_Primitives closesocket__0(global::System.IntPtr socketHandle)
		{
			// Setup
			global::System.Net.Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.ws2_32_dll_PInvokes.closesocket__0(socketHandle);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, freeaddrinfo, [fwd] [return] [Mcg.CodeGen.VoidReturnMarshaller] void__void, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "freeaddrinfo")]
		public static void freeaddrinfo(global::System.IntPtr info)
		{
			// Marshalling
			// Call to native method
			global::McgInterop.ws2_32_dll_PInvokes.freeaddrinfo(info);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'ntdll.dll'
	/// </summary>
	public unsafe static partial class ntdll_dll
	{
		// Signature, RtlIpv6StringToAddressExW, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] ushort__unsigned short, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Primitives, Version=4.0.12.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NtDll", "RtlIpv6StringToAddressExW")]
		public static uint RtlIpv6StringToAddressExW(
					string s, 
					byte[] address, 
					out uint scopeId, 
					out ushort port)
		{
			// Setup
			ushort* unsafe_s = default(ushort*);
			byte* unsafe_address;
			uint unsafe_scopeId;
			ushort unsafe_port;
			uint unsafe___value;
			// Marshalling
			fixed (char* pinned_s = s)
			{
				unsafe_s = (ushort*)pinned_s;
				fixed (byte* pinned_address = global::McgInterop.McgCoreHelpers.GetArrayForCompat(address))
				{
					unsafe_address = (byte*)pinned_address;
					// Call to native method
					unsafe___value = global::McgInterop.ntdll_dll_PInvokes.RtlIpv6StringToAddressExW(
										unsafe_s, 
										unsafe_address, 
										&(unsafe_scopeId), 
										&(unsafe_port)
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					port = unsafe_port;
					scopeId = unsafe_scopeId;
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, RtlIpv4StringToAddressExW, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] ushort__unsigned short, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Primitives, Version=4.0.12.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NtDll", "RtlIpv4StringToAddressExW")]
		public static uint RtlIpv4StringToAddressExW(
					string s, 
					bool strict, 
					byte[] address, 
					out ushort port)
		{
			// Setup
			ushort* unsafe_s = default(ushort*);
			byte* unsafe_address;
			ushort unsafe_port;
			uint unsafe___value;
			// Marshalling
			fixed (char* pinned_s = s)
			{
				unsafe_s = (ushort*)pinned_s;
				fixed (byte* pinned_address = global::McgInterop.McgCoreHelpers.GetArrayForCompat(address))
				{
					unsafe_address = (byte*)pinned_address;
					// Call to native method
					unsafe___value = global::McgInterop.ntdll_dll_PInvokes.RtlIpv4StringToAddressExW(
										unsafe_s, 
										(strict ? 1 : 0), 
										unsafe_address, 
										&(unsafe_port)
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					port = unsafe_port;
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, RtlIpv6AddressToStringExW, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] ushort__unsigned short, [fwd] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Primitives, Version=4.0.12.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NtDll", "RtlIpv6AddressToStringExW")]
		public static uint RtlIpv6AddressToStringExW(
					byte[] address, 
					uint scopeId, 
					ushort port, 
					global::System.Text.StringBuilder addressString, 
					ref uint addressStringLength)
		{
			// Setup
			byte* unsafe_address;
			ushort* unsafe_addressString = default(ushort*);
			uint unsafe_addressStringLength;
			uint unsafe___value;
			try
			{
				// Marshalling
				fixed (byte* pinned_address = global::McgInterop.McgCoreHelpers.GetArrayForCompat(address))
				{
					unsafe_address = (byte*)pinned_address;
					if (addressString == null)
						unsafe_addressString = null;
					else
					{
						unsafe_addressString = (ushort*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(addressString.Capacity * 2 
											+ 2)));
						if (unsafe_addressString == null)
							throw new global::System.OutOfMemoryException();
					}
					unsafe_addressStringLength = addressStringLength;
					// Call to native method
					unsafe___value = global::McgInterop.ntdll_dll_PInvokes.RtlIpv6AddressToStringExW(
										unsafe_address, 
										scopeId, 
										port, 
										unsafe_addressString, 
										&(unsafe_addressStringLength)
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					addressStringLength = unsafe_addressStringLength;
					if (addressString != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_addressString, 
											addressString
										);
				}
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_addressString != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_addressString);
			}
		}

		// Signature, RtlIpv4AddressToStringExW, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, [fwd] [in] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] ushort__unsigned short, [fwd] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Primitives, Version=4.0.12.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NtDll", "RtlIpv4AddressToStringExW")]
		public static uint RtlIpv4AddressToStringExW(
					byte[] address, 
					ushort port, 
					global::System.Text.StringBuilder addressString, 
					ref uint addressStringLength)
		{
			// Setup
			byte* unsafe_address;
			ushort* unsafe_addressString = default(ushort*);
			uint unsafe_addressStringLength;
			uint unsafe___value;
			try
			{
				// Marshalling
				fixed (byte* pinned_address = global::McgInterop.McgCoreHelpers.GetArrayForCompat(address))
				{
					unsafe_address = (byte*)pinned_address;
					if (addressString == null)
						unsafe_addressString = null;
					else
					{
						unsafe_addressString = (ushort*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(addressString.Capacity * 2 
											+ 2)));
						if (unsafe_addressString == null)
							throw new global::System.OutOfMemoryException();
					}
					unsafe_addressStringLength = addressStringLength;
					// Call to native method
					unsafe___value = global::McgInterop.ntdll_dll_PInvokes.RtlIpv4AddressToStringExW(
										unsafe_address, 
										port, 
										unsafe_addressString, 
										&(unsafe_addressStringLength)
									);
					global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
					addressStringLength = unsafe_addressStringLength;
					if (addressString != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_addressString, 
											addressString
										);
				}
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_addressString != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_addressString);
			}
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-robuffer-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_robuffer_l1_1_0_dll
	{
		// Signature, RoGetBufferMarshaler, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.ComInterfaceMarshaller] System_Runtime_InteropServices_IMarshal__System_Runtime_WindowsRuntime__System_Runtime_InteropServices__IMarshal__System_Runtime_WindowsRuntime *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Runtime.WindowsRuntime, Version=4.0.12.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "Interop+mincore", "RoGetBufferMarshaler")]
		public static int RoGetBufferMarshaler(out global::System.Runtime.InteropServices.IMarshal__System_Runtime_WindowsRuntime bufferMarshalerPtr)
		{
			// Setup
			global::System.Runtime.InteropServices.IMarshal__System_Runtime_WindowsRuntime__Impl.Vtbl** unsafe_bufferMarshalerPtr = default(global::System.Runtime.InteropServices.IMarshal__System_Runtime_WindowsRuntime__Impl.Vtbl**);
			int unsafe___value;
			try
			{
				// Marshalling
				unsafe_bufferMarshalerPtr = null;
				// Call to native method
				unsafe___value = global::McgInterop.api_ms_win_core_winrt_robuffer_l1_1_0_dll_PInvokes.RoGetBufferMarshaler(&(unsafe_bufferMarshalerPtr));
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				bufferMarshalerPtr = (global::System.Runtime.InteropServices.IMarshal__System_Runtime_WindowsRuntime)global::System.Runtime.InteropServices.McgModuleManager.ComInterfaceToObject(
									((global::System.IntPtr)unsafe_bufferMarshalerPtr), 
									global::System.Runtime.InteropServices.TypeOfHelper.RuntimeTypeHandleOf("System.Runtime.InteropServices.IMarshal,System.Runtime.WindowsRuntime, Version=4.0.12.0, Culture=neutral, Public" +
											"KeyToken=b77a5c561934e089")
								);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.McgMarshal.ComSafeRelease(new global::System.IntPtr(((void*)unsafe_bufferMarshalerPtr)));
			}
		}
	}

	/// <summary>
	/// P/Invoke class for module 'crypt32.dll'
	/// </summary>
	public unsafe static partial class crypt32_dll
	{
		// Signature, CertDuplicateCertificateContext, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertDuplicateCertificateContext")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates CertDuplicateCertificateContext(global::System.IntPtr pCertContext)
		{
			// Setup
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
			// Call to native method
			unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CertDuplicateCertificateContext(pCertContext);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, CertGetCertificateContextProperty, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CertContextPropId__System_Security_Cryptography_X509Certificates__CertContextPropId__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Internal_Cryptography_Pal_Native_CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetCertificateContextProperty")]
		public static bool CertGetCertificateContextProperty(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal.Cryptography.Pal.Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					out global::Internal.Cryptography.Pal.Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			global::Internal.Cryptography.Pal.Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates unsafe_pvData;
			int unsafe_pcbData;
			int unsafe___value;
			// Marshalling
			pCertContext.DangerousAddRef(ref addRefed);
			unsafe_pcbData = pcbData;
			// Call to native method
			unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CertGetCertificateContextProperty(
								pCertContext.DangerousGetHandle(), 
								dwPropId, 
								&(unsafe_pvData), 
								&(unsafe_pcbData)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			pcbData = unsafe_pcbData;
			pvData = unsafe_pvData;
			if (addRefed)
				pCertContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertGetCertificateContextProperty__0, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CertContextPropId__System_Security_Cryptography_X509Certificates__CertContextPropId__System_Security_Cryptography_X509Certificates, [fwd] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetCertificateContextProperty")]
		public static bool CertGetCertificateContextProperty__0(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal.Cryptography.Pal.Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					byte[] pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pvData;
			int unsafe_pcbData;
			int unsafe___value;
			// Marshalling
			pCertContext.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pvData = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pvData))
			{
				unsafe_pvData = (byte*)pinned_pvData;
				unsafe_pcbData = pcbData;
				// Call to native method
				unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CertGetCertificateContextProperty__0(
									pCertContext.DangerousGetHandle(), 
									dwPropId, 
									unsafe_pvData, 
									&(unsafe_pcbData)
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				pcbData = unsafe_pcbData;
			}
			if (addRefed)
				pCertContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertDuplicateCertificateContextWithKeyContainerDeletion, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertDuplicateCertificateContextWithKeyContainerDeletion")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates CertDuplicateCertificateContextWithKeyContainerDeletion(global::System.IntPtr pCertContext)
		{
			// Setup
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates();
			// Call to native method
			unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CertDuplicateCertificateContextWithKeyContainerDeletion(pCertContext);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, CryptQueryObject, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CertQueryObjectType__System_Security_Cryptography_X509Certificates__CertQueryObjectType__System_Security_Cryptography_X509Certificates, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates__ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates__ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_ContentType__System_Security_Cryptography_X509Certificates__ContentType__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_FormatType__System_Security_Cryptography_X509Certificates__FormatType__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptQueryObject")]
		public static bool CryptQueryObject(
					global::Internal.Cryptography.Pal.Native.CertQueryObjectType__System_Security_Cryptography_X509Certificates dwObjectType, 
					void* pvObject, 
					global::Internal.Cryptography.Pal.Native.ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedContentTypeFlags, 
					global::Internal.Cryptography.Pal.Native.ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedFormatTypeFlags, 
					int dwFlags, 
					out global::Internal.Cryptography.Pal.Native.CertEncodingType__System_Security_Cryptography_X509Certificates pdwMsgAndCertEncodingType, 
					out global::Internal.Cryptography.Pal.Native.ContentType__System_Security_Cryptography_X509Certificates pdwContentType, 
					out global::Internal.Cryptography.Pal.Native.FormatType__System_Security_Cryptography_X509Certificates pdwFormatType, 
					out global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates phCertStore, 
					out global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates phMsg, 
					out global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates ppvContext)
		{
			// Setup
			global::Internal.Cryptography.Pal.Native.CertEncodingType__System_Security_Cryptography_X509Certificates unsafe_pdwMsgAndCertEncodingType;
			global::Internal.Cryptography.Pal.Native.ContentType__System_Security_Cryptography_X509Certificates unsafe_pdwContentType;
			global::Internal.Cryptography.Pal.Native.FormatType__System_Security_Cryptography_X509Certificates unsafe_pdwFormatType;
			global::System.IntPtr unsafe_phCertStore;
			global::System.IntPtr unsafe_phMsg;
			global::System.IntPtr unsafe_ppvContext;
			int unsafe___value;
			// Marshalling
			phCertStore = new global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates();
			unsafe_phCertStore = phCertStore.DangerousGetHandle();
			phMsg = new global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates();
			unsafe_phMsg = phMsg.DangerousGetHandle();
			ppvContext = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
			unsafe_ppvContext = ppvContext.DangerousGetHandle();
			// Call to native method
			unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CryptQueryObject(
								dwObjectType, 
								((void*)pvObject), 
								dwExpectedContentTypeFlags, 
								dwExpectedFormatTypeFlags, 
								dwFlags, 
								&(unsafe_pdwMsgAndCertEncodingType), 
								&(unsafe_pdwContentType), 
								&(unsafe_pdwFormatType), 
								&(unsafe_phCertStore), 
								&(unsafe_phMsg), 
								&(unsafe_ppvContext)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								ppvContext, 
								unsafe_ppvContext
							);
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phMsg, 
								unsafe_phMsg
							);
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phCertStore, 
								unsafe_phCertStore
							);
			pdwFormatType = unsafe_pdwFormatType;
			pdwContentType = unsafe_pdwContentType;
			pdwMsgAndCertEncodingType = unsafe_pdwMsgAndCertEncodingType;
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertFreeCertificateContext, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertFreeCertificateContext")]
		public static bool CertFreeCertificateContext(global::System.IntPtr pCertContext)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CertFreeCertificateContext(pCertContext);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptMsgGetParam, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CryptMessageParameterType__System_Security_Cryptography_X509Certificates__CryptMessageParameterType__System_Security_Cryptography_X509Certificates, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptMsgGetParam")]
		public static bool CryptMsgGetParam(
					global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates hCryptMsg, 
					global::Internal.Cryptography.Pal.Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					out int pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			int unsafe_pvData;
			int unsafe_pcbData;
			int unsafe___value;
			// Marshalling
			hCryptMsg.DangerousAddRef(ref addRefed);
			unsafe_pcbData = pcbData;
			// Call to native method
			unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CryptMsgGetParam(
								hCryptMsg.DangerousGetHandle(), 
								dwParamType, 
								dwIndex, 
								&(unsafe_pvData), 
								&(unsafe_pcbData)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			pcbData = unsafe_pcbData;
			pvData = unsafe_pvData;
			if (addRefed)
				hCryptMsg.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptMsgGetParam__0, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CryptMessageParameterType__System_Security_Cryptography_X509Certificates__CryptMessageParameterType__System_Security_Cryptography_X509Certificates, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [Mcg.CodeGen.BlittableArrayMarshaller] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptMsgGetParam")]
		public static bool CryptMsgGetParam__0(
					global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates hCryptMsg, 
					global::Internal.Cryptography.Pal.Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					byte[] pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pvData;
			int unsafe_pcbData;
			int unsafe___value;
			// Marshalling
			hCryptMsg.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pvData = global::McgInterop.McgCoreHelpers.GetArrayForCompat(pvData))
			{
				unsafe_pvData = (byte*)pinned_pvData;
				unsafe_pcbData = pcbData;
				// Call to native method
				unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CryptMsgGetParam__0(
									hCryptMsg.DangerousGetHandle(), 
									dwParamType, 
									dwIndex, 
									unsafe_pvData, 
									&(unsafe_pcbData)
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				pcbData = unsafe_pcbData;
			}
			if (addRefed)
				hCryptMsg.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, PFXImportCertStore, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Internal_Cryptography_Pal_Native_CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_PfxCertStoreFlags__System_Security_Cryptography_X509Certificates__PfxCertStoreFlags__System_Security_Cryptography_X509Certificates, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "PFXImportCertStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates PFXImportCertStore(
					ref global::Internal.Cryptography.Pal.Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates pPFX, 
					string szPassword, 
					global::Internal.Cryptography.Pal.Native.PfxCertStoreFlags__System_Security_Cryptography_X509Certificates dwFlags)
		{
			// Setup
			global::Internal.Cryptography.Pal.Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates unsafe_pPFX;
			ushort* unsafe_szPassword = default(ushort*);
			global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			unsafe_pPFX = pPFX;
			fixed (char* pinned_szPassword = szPassword)
			{
				unsafe_szPassword = (ushort*)pinned_szPassword;
				__value = new global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates();
				// Call to native method
				unsafe___value = global::McgInterop.crypt32_dll_PInvokes.PFXImportCertStore(
									&(unsafe_pPFX), 
									unsafe_szPassword, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									__value, 
									unsafe___value
								);
			}
			// Return
			return __value;
		}

		// Signature, CertGetNameString, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CertNameType__System_Security_Cryptography_X509Certificates__CertNameType__System_Security_Cryptography_X509Certificates, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CertNameFlags__System_Security_Cryptography_X509Certificates__CertNameFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [managedbyref] [nativebyref] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CertNameStringType__System_Security_Cryptography_X509Certificates__CertNameStringType__System_Security_Cryptography_X509Certificates, [fwd] [out] [Mcg.CodeGen.StringBuilderMarshaller] System_Text_StringBuilder__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetNameString")]
		public static int CertGetNameString(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal.Cryptography.Pal.Native.CertNameType__System_Security_Cryptography_X509Certificates dwType, 
					global::Internal.Cryptography.Pal.Native.CertNameFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					ref global::Internal.Cryptography.Pal.Native.CertNameStringType__System_Security_Cryptography_X509Certificates pvTypePara, 
					global::System.Text.StringBuilder pszNameString, 
					int cchNameString)
		{
			// Setup
			bool addRefed = false;
			global::Internal.Cryptography.Pal.Native.CertNameStringType__System_Security_Cryptography_X509Certificates unsafe_pvTypePara;
			ushort* unsafe_pszNameString = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				pCertContext.DangerousAddRef(ref addRefed);
				unsafe_pvTypePara = pvTypePara;
				if (pszNameString == null)
					unsafe_pszNameString = null;
				else
				{
					unsafe_pszNameString = (ushort*)global::McgInterop.McgHelpers.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pszNameString.Capacity * 2 
										+ 2)));
					if (unsafe_pszNameString == null)
						throw new global::System.OutOfMemoryException();
				}
				// Call to native method
				unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CertGetNameString(
									pCertContext.DangerousGetHandle(), 
									dwType, 
									dwFlags, 
									&(unsafe_pvTypePara), 
									unsafe_pszNameString, 
									cchNameString
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (pszNameString != null)
					global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
										unsafe_pszNameString, 
										pszNameString
									);
				if (addRefed)
					pCertContext.DangerousRelease();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_pszNameString != null)
					global::System.Runtime.InteropServices.ExternalInterop.SafeCoTaskMemFree(unsafe_pszNameString);
			}
		}

		// Signature, CertCloseStore, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertCloseStore")]
		public static bool CertCloseStore(
					global::System.IntPtr hCertStore, 
					int dwFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CertCloseStore(
								hCertStore, 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptMsgClose, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptMsgClose")]
		public static bool CryptMsgClose(global::System.IntPtr hCryptMsg)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CryptMsgClose(hCryptMsg);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertFindCertificateInStore, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CertFindFlags__System_Security_Cryptography_X509Certificates__CertFindFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Internal_Cryptography_Pal_Native_CertFindType__System_Security_Cryptography_X509Certificates__CertFindType__System_Security_Cryptography_X509Certificates, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] void___ptrvoid *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] Internal_Cryptography_Pal_Native_CERT_CONTEXT__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_CONTEXT__System_Security_Cryptography_X509Certificates *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertFindCertificateInStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates CertFindCertificateInStore(
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hCertStore, 
					global::Internal.Cryptography.Pal.Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal.Cryptography.Pal.Native.CertFindFlags__System_Security_Cryptography_X509Certificates dwFindFlags, 
					global::Internal.Cryptography.Pal.Native.CertFindType__System_Security_Cryptography_X509Certificates dwFindType, 
					void* pvFindPara, 
					global::Internal.Cryptography.Pal.Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext)
		{
			// Setup
			bool addRefed = false;
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			hCertStore.DangerousAddRef(ref addRefed);
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
			// Call to native method
			unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CertFindCertificateInStore(
								hCertStore.DangerousGetHandle(), 
								dwCertEncodingType, 
								dwFindFlags, 
								dwFindType, 
								((void*)pvFindPara), 
								((global::Internal.Cryptography.Pal.Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates*)pPrevCertContext)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			if (addRefed)
				hCertStore.DangerousRelease();
			// Return
			return __value;
		}

		// Signature, CertEnumCertificatesInStore, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] Internal_Cryptography_Pal_Native_CERT_CONTEXT__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_CONTEXT__System_Security_Cryptography_X509Certificates *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertEnumCertificatesInStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates CertEnumCertificatesInStore(
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hCertStore, 
					global::Internal.Cryptography.Pal.Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext)
		{
			// Setup
			bool addRefed = false;
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			hCertStore.DangerousAddRef(ref addRefed);
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
			// Call to native method
			unsafe___value = global::McgInterop.crypt32_dll_PInvokes.CertEnumCertificatesInStore(
								hCertStore.DangerousGetHandle(), 
								((global::Internal.Cryptography.Pal.Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates*)pPrevCertContext)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			if (addRefed)
				hCertStore.DangerousRelease();
			// Return
			return __value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-threadpool-l1-2-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_threadpool_l1_2_0_dll
	{
		// Signature, CreateThreadpoolIo, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeThreadPoolIOHandle__System_Threading_Overlapped____w64 int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.PInvokeDelegateMarshaller] Interop_NativeIoCompletionCallback__System_Threading_Overlapped____Interop_NativeIoCompletionCallback__System_Threading_Overlapped, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Threading.Overlapped, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "CreateThreadpoolIo")]
		public static global::Microsoft.Win32.SafeHandles.SafeThreadPoolIOHandle__System_Threading_Overlapped CreateThreadpoolIo(
					global::System.Runtime.InteropServices.SafeHandle fl, 
					global::Interop_NativeIoCompletionCallback__System_Threading_Overlapped pfnio, 
					global::System.IntPtr context, 
					global::System.IntPtr pcbe)
		{
			// Setup
			bool addRefed = false;
			void* unsafe_pfnio = default(void*);
			global::Microsoft.Win32.SafeHandles.SafeThreadPoolIOHandle__System_Threading_Overlapped __value;
			global::System.IntPtr unsafe___value;
			try
			{
				// Marshalling
				fl.DangerousAddRef(ref addRefed);
				unsafe_pfnio = (void*)global::System.Runtime.InteropServices.McgModuleManager.GetStubForPInvokeDelegate(
									global::System.Runtime.InteropServices.TypeOfHelper.RuntimeTypeHandleOf("Interop+NativeIoCompletionCallback,System.Threading.Overlapped, Version=4.0.2.0, Culture=neutral, PublicKeyToken" +
											"=b03f5f7f11d50a3a"), 
									pfnio
								);
				__value = new global::Microsoft.Win32.SafeHandles.SafeThreadPoolIOHandle__System_Threading_Overlapped();
				// Call to native method
				unsafe___value = global::McgInterop.api_ms_win_core_threadpool_l1_2_0_dll_PInvokes.CreateThreadpoolIo(
									fl.DangerousGetHandle(), 
									unsafe_pfnio, 
									context, 
									pcbe
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									__value, 
									unsafe___value
								);
				if (addRefed)
					fl.DangerousRelease();
				// Return
				return __value;
			}
			finally
			{
				// Cleanup
				global::System.GC.KeepAlive(pfnio);
			}
		}

		// Signature, StartThreadpoolIo, [fwd] [return] [Mcg.CodeGen.VoidReturnMarshaller] void__void, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeThreadPoolIOHandle__System_Threading_Overlapped____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Threading.Overlapped, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "StartThreadpoolIo")]
		public static void StartThreadpoolIo(global::Microsoft.Win32.SafeHandles.SafeThreadPoolIOHandle__System_Threading_Overlapped pio)
		{
			// Setup
			bool addRefed = false;
			// Marshalling
			pio.DangerousAddRef(ref addRefed);
			// Call to native method
			global::McgInterop.api_ms_win_core_threadpool_l1_2_0_dll_PInvokes.StartThreadpoolIo(pio.DangerousGetHandle());
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			if (addRefed)
				pio.DangerousRelease();
			// Return
		}

		// Signature, CancelThreadpoolIo, [fwd] [return] [Mcg.CodeGen.VoidReturnMarshaller] void__void, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeThreadPoolIOHandle__System_Threading_Overlapped____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Threading.Overlapped, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "CancelThreadpoolIo")]
		public static void CancelThreadpoolIo(global::Microsoft.Win32.SafeHandles.SafeThreadPoolIOHandle__System_Threading_Overlapped pio)
		{
			// Setup
			bool addRefed = false;
			// Marshalling
			pio.DangerousAddRef(ref addRefed);
			// Call to native method
			global::McgInterop.api_ms_win_core_threadpool_l1_2_0_dll_PInvokes.CancelThreadpoolIo(pio.DangerousGetHandle());
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			if (addRefed)
				pio.DangerousRelease();
			// Return
		}

		// Signature, CloseThreadpoolIo, [fwd] [return] [Mcg.CodeGen.VoidReturnMarshaller] void__void, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Threading.Overlapped, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "CloseThreadpoolIo")]
		public static void CloseThreadpoolIo(global::System.IntPtr pio)
		{
			// Marshalling
			// Call to native method
			global::McgInterop.api_ms_win_core_threadpool_l1_2_0_dll_PInvokes.CloseThreadpoolIo(pio);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-com-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_com_l1_1_0_dll
	{
		// Signature, CoCreateInstance, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.StackTraceGenerator, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.StackTraceGenerator.StackTraceGenerator", "CoCreateInstance")]
		public static int CoCreateInstance(
					byte* rclsid, 
					global::System.IntPtr pUnkOuter, 
					int dwClsContext, 
					byte* riid, 
					out global::System.IntPtr ppv)
		{
			// Setup
			global::System.IntPtr unsafe_ppv;
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_com_l1_1_0_dll_PInvokes.CoCreateInstance(
								((byte*)rclsid), 
								pUnkOuter, 
								dwClsContext, 
								((byte*)riid), 
								&(unsafe_ppv)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			ppv = unsafe_ppv;
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'OleAut32'
	/// </summary>
	public unsafe static partial class OleAut32
	{
		// Signature, SysFreeString, [fwd] [return] [Mcg.CodeGen.VoidReturnMarshaller] void__void, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.StackTraceGenerator, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.LightweightInterop.MarshalExtensions", "SysFreeString")]
		public static void SysFreeString(global::System.IntPtr bstr)
		{
			// Marshalling
			// Call to native method
			global::McgInterop.OleAut32_PInvokes.SysFreeString(bstr);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'ncrypt.dll'
	/// </summary>
	public unsafe static partial class ncrypt_dll
	{
		// Signature, NCryptOpenKey, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] System_Security_Cryptography_CngKeyOpenOptions__System_Security_Cryptography_Cng__CngKeyOpenOptions__System_Security_Cryptography_Cng, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptOpenKey")]
		public static global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenKey(
					global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng hProvider, 
					out global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng phKey, 
					string pszKeyName, 
					int dwLegacyKeySpec, 
					global::System.Security.Cryptography.CngKeyOpenOptions__System_Security_Cryptography_Cng dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_phKey;
			ushort* unsafe_pszKeyName = default(ushort*);
			global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			phKey = new global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng();
			unsafe_phKey = phKey.DangerousGetHandle();
			fixed (char* pinned_pszKeyName = pszKeyName)
			{
				unsafe_pszKeyName = (ushort*)pinned_pszKeyName;
				// Call to native method
				unsafe___value = global::McgInterop.ncrypt_dll_PInvokes.NCryptOpenKey(
									hProvider.DangerousGetHandle(), 
									&(unsafe_phKey), 
									unsafe_pszKeyName, 
									dwLegacyKeySpec, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phKey, 
								unsafe_phKey
							);
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptDeleteKey, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptDeleteKey")]
		public static global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptDeleteKey(
					global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng hKey, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.ncrypt_dll_PInvokes.NCryptDeleteKey(
								hKey.DangerousGetHandle(), 
								dwFlags
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptOpenStorageProvider, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptOpenStorageProvider")]
		public static global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenStorageProvider(
					out global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng phProvider, 
					string pszProviderName, 
					int dwFlags)
		{
			// Setup
			global::System.IntPtr unsafe_phProvider;
			ushort* unsafe_pszProviderName = default(ushort*);
			global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			phProvider = new global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng();
			unsafe_phProvider = phProvider.DangerousGetHandle();
			fixed (char* pinned_pszProviderName = pszProviderName)
			{
				unsafe_pszProviderName = (ushort*)pinned_pszProviderName;
				// Call to native method
				unsafe___value = global::McgInterop.ncrypt_dll_PInvokes.NCryptOpenStorageProvider(
									&(unsafe_phProvider), 
									unsafe_pszProviderName, 
									dwFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phProvider, 
								unsafe_phProvider
							);
			// Return
			return unsafe___value;
		}

		// Signature, NCryptFreeObject, [fwd] [return] [Mcg.CodeGen.EnumMarshaller] Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptFreeObject")]
		public static global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptFreeObject(global::System.IntPtr hObject)
		{
			// Setup
			global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.ncrypt_dll_PInvokes.NCryptFreeObject(hObject);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-file-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_file_l1_1_0_dll
	{
		// Signature, GetFileType, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "GetFileType")]
		public static int GetFileType(global::System.Runtime.InteropServices.SafeHandle hFile)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hFile.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.GetFileType(hFile.DangerousGetHandle());
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hFile.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, SetFilePointerEx, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeFileHandle__System_IO_FileSystem____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] long____int64, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] long____int64, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "SetFilePointerEx")]
		public static bool SetFilePointerEx(
					global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_IO_FileSystem hFile, 
					long liDistanceToMove, 
					out long lpNewFilePointer, 
					uint dwMoveMethod)
		{
			// Setup
			bool addRefed = false;
			long unsafe_lpNewFilePointer;
			int unsafe___value;
			// Marshalling
			hFile.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.SetFilePointerEx(
								hFile.DangerousGetHandle(), 
								liDistanceToMove, 
								&(unsafe_lpNewFilePointer), 
								dwMoveMethod
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			lpNewFilePointer = unsafe_lpNewFilePointer;
			if (addRefed)
				hFile.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, SetEndOfFile, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeFileHandle__System_IO_FileSystem____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "SetEndOfFile")]
		public static bool SetEndOfFile(global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_IO_FileSystem hFile)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hFile.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.SetEndOfFile(hFile.DangerousGetHandle());
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hFile.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, GetFileAttributesExPrivate, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Interop_mincore_GET_FILEEX_INFO_LEVELS__System_IO_FileSystem__Interop_mincore_GET_FILEEX_INFO_LEVELS__System_IO_FileSystem, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Interop_mincore_WIN32_FILE_ATTRIBUTE_DATA__System_IO_FileSystem____Interop_mincore_WIN32_FILE_ATTRIBUTE_DATA__System_IO_FileSystem, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "GetFileAttributesExPrivate")]
		public static bool GetFileAttributesExPrivate(
					string name, 
					global::Interop_mincore_GET_FILEEX_INFO_LEVELS__System_IO_FileSystem fileInfoLevel, 
					ref global::Interop_mincore_WIN32_FILE_ATTRIBUTE_DATA__System_IO_FileSystem lpFileInformation)
		{
			// Setup
			ushort* unsafe_name = default(ushort*);
			global::Interop_mincore_WIN32_FILE_ATTRIBUTE_DATA__System_IO_FileSystem unsafe_lpFileInformation;
			int unsafe___value;
			// Marshalling
			fixed (char* pinned_name = name)
			{
				unsafe_name = (ushort*)pinned_name;
				unsafe_lpFileInformation = lpFileInformation;
				// Call to native method
				unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.GetFileAttributesExPrivate(
									unsafe_name, 
									fileInfoLevel, 
									&(unsafe_lpFileInformation)
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				lpFileInformation = unsafe_lpFileInformation;
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, FindFirstFileExPrivate, [fwd] [return] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeFindHandle__System_IO_FileSystem____w64 int, [fwd] [in] [Mcg.CodeGen.UnicodeStringMarshaller] string__wchar_t *, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Interop_mincore_FINDEX_INFO_LEVELS__System_IO_FileSystem__Interop_mincore_FINDEX_INFO_LEVELS__System_IO_FileSystem, [fwd] [in] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.StructMarshaller] Interop_mincore_WIN32_FIND_DATA__System_IO_FileSystem____Interop_mincore_WIN32_FIND_DATA__System_IO_FileSystem, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Interop_mincore_FINDEX_SEARCH_OPS__System_IO_FileSystem__Interop_mincore_FINDEX_SEARCH_OPS__System_IO_FileSystem, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "FindFirstFileExPrivate")]
		public static global::Microsoft.Win32.SafeHandles.SafeFindHandle__System_IO_FileSystem FindFirstFileExPrivate(
					string lpFileName, 
					global::Interop_mincore_FINDEX_INFO_LEVELS__System_IO_FileSystem fInfoLevelId, 
					ref global::Interop_mincore_WIN32_FIND_DATA__System_IO_FileSystem lpFindFileData, 
					global::Interop_mincore_FINDEX_SEARCH_OPS__System_IO_FileSystem fSearchOp, 
					global::System.IntPtr lpSearchFilter, 
					int dwAdditionalFlags)
		{
			// Setup
			ushort* unsafe_lpFileName = default(ushort*);
			global::Interop_mincore_WIN32_FIND_DATA__System_IO_FileSystem__Impl.UnsafeType unsafe_lpFindFileData = default(global::Interop_mincore_WIN32_FIND_DATA__System_IO_FileSystem__Impl.UnsafeType);
			global::Microsoft.Win32.SafeHandles.SafeFindHandle__System_IO_FileSystem __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			fixed (char* pinned_lpFileName = lpFileName)
			{
				unsafe_lpFileName = (ushort*)pinned_lpFileName;
				global::Interop_mincore_WIN32_FIND_DATA__System_IO_FileSystem__Impl.Marshal__SafeToUnsafe(
									ref lpFindFileData, 
									out unsafe_lpFindFileData
								);
				__value = new global::Microsoft.Win32.SafeHandles.SafeFindHandle__System_IO_FileSystem();
				// Call to native method
				unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.FindFirstFileExPrivate(
									unsafe_lpFileName, 
									fInfoLevelId, 
									&(unsafe_lpFindFileData), 
									fSearchOp, 
									lpSearchFilter, 
									dwAdditionalFlags
								);
				global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									__value, 
									unsafe___value
								);
				global::Interop_mincore_WIN32_FIND_DATA__System_IO_FileSystem__Impl.Marshal__UnsafeToSafe(
									ref unsafe_lpFindFileData, 
									out lpFindFileData
								);
			}
			// Return
			return __value;
		}

		// Signature, ReadFile, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_Threading_NativeOverlapped__System_Threading_Overlapped___ptrSystem_Threading__NativeOverlapped__System_Threading_Overlapped *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "ReadFile")]
		public static int ReadFile(
					global::System.Runtime.InteropServices.SafeHandle handle, 
					byte* bytes, 
					int numBytesToRead, 
					global::System.IntPtr numBytesRead_mustBeZero, 
					global::System.Threading.NativeOverlapped__System_Threading_Overlapped* overlapped)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			handle.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.ReadFile(
								handle.DangerousGetHandle(), 
								((byte*)bytes), 
								numBytesToRead, 
								numBytesRead_mustBeZero, 
								((global::System.Threading.NativeOverlapped__System_Threading_Overlapped*)overlapped)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				handle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, ReadFile__0, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "ReadFile")]
		public static int ReadFile__0(
					global::System.Runtime.InteropServices.SafeHandle handle, 
					byte* bytes, 
					int numBytesToRead, 
					out int numBytesRead, 
					global::System.IntPtr mustBeZero)
		{
			// Setup
			bool addRefed = false;
			int unsafe_numBytesRead;
			int unsafe___value;
			// Marshalling
			handle.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.ReadFile__0(
								handle.DangerousGetHandle(), 
								((byte*)bytes), 
								numBytesToRead, 
								&(unsafe_numBytesRead), 
								mustBeZero
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			numBytesRead = unsafe_numBytesRead;
			if (addRefed)
				handle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WriteFile, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_Threading_NativeOverlapped__System_Threading_Overlapped___ptrSystem_Threading__NativeOverlapped__System_Threading_Overlapped *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "WriteFile")]
		public static int WriteFile(
					global::System.Runtime.InteropServices.SafeHandle handle, 
					byte* bytes, 
					int numBytesToWrite, 
					global::System.IntPtr numBytesWritten_mustBeZero, 
					global::System.Threading.NativeOverlapped__System_Threading_Overlapped* lpOverlapped)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			handle.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.WriteFile(
								handle.DangerousGetHandle(), 
								((byte*)bytes), 
								numBytesToWrite, 
								numBytesWritten_mustBeZero, 
								((global::System.Threading.NativeOverlapped__System_Threading_Overlapped*)lpOverlapped)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				handle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WriteFile__0, [fwd] [return] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] byte___ptrunsigned char *, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableValueMarshaller] int__int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "WriteFile")]
		public static int WriteFile__0(
					global::System.Runtime.InteropServices.SafeHandle handle, 
					byte* bytes, 
					int numBytesToWrite, 
					out int numBytesWritten, 
					global::System.IntPtr mustBeZero)
		{
			// Setup
			bool addRefed = false;
			int unsafe_numBytesWritten;
			int unsafe___value;
			// Marshalling
			handle.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.WriteFile__0(
								handle.DangerousGetHandle(), 
								((byte*)bytes), 
								numBytesToWrite, 
								&(unsafe_numBytesWritten), 
								mustBeZero
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			numBytesWritten = unsafe_numBytesWritten;
			if (addRefed)
				handle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, FindClose, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "FindClose")]
		public static bool FindClose(global::System.IntPtr hFindFile)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.FindClose(hFindFile);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, FlushFileBuffers, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "FlushFileBuffers")]
		public static bool FlushFileBuffers(global::System.Runtime.InteropServices.SafeHandle hHandle)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hHandle.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l1_1_0_dll_PInvokes.FlushFileBuffers(hHandle.DangerousGetHandle());
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-file-l2-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_file_l2_1_0_dll
	{
		// Signature, GetFileInformationByHandleEx, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] Microsoft_Win32_SafeHandles_SafeFileHandle__System_IO_FileSystem____w64 int, [fwd] [in] [Mcg.CodeGen.EnumMarshaller] Interop_mincore_FILE_INFO_BY_HANDLE_CLASS__System_IO_FileSystem__Interop_mincore_FILE_INFO_BY_HANDLE_CLASS__System_IO_FileSystem, [fwd] [out] [managedbyref] [nativebyref] [Mcg.CodeGen.BlittableStructMarshaller] Interop_mincore_FILE_STANDARD_INFO__System_IO_FileSystem____Interop_mincore_FILE_STANDARD_INFO__System_IO_FileSystem, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "GetFileInformationByHandleEx")]
		public static bool GetFileInformationByHandleEx(
					global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_IO_FileSystem hFile, 
					global::Interop_mincore_FILE_INFO_BY_HANDLE_CLASS__System_IO_FileSystem FileInformationClass, 
					out global::Interop_mincore_FILE_STANDARD_INFO__System_IO_FileSystem lpFileInformation, 
					uint dwBufferSize)
		{
			// Setup
			bool addRefed = false;
			global::Interop_mincore_FILE_STANDARD_INFO__System_IO_FileSystem unsafe_lpFileInformation;
			int unsafe___value;
			// Marshalling
			hFile.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_file_l2_1_0_dll_PInvokes.GetFileInformationByHandleEx(
								hFile.DangerousGetHandle(), 
								FileInformationClass, 
								&(unsafe_lpFileInformation), 
								dwBufferSize
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			lpFileInformation = unsafe_lpFileInformation;
			if (addRefed)
				hFile.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-io-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_io_l1_1_0_dll
	{
		// Signature, CancelIoEx, [fwd] [return] [Mcg.CodeGen.Win32BoolMarshaller] bool__System.Boolean, [fwd] [in] [Mcg.CodeGen.Win32HandleMarshaller] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [Mcg.CodeGen.BlittableValueMarshaller] System_Threading_NativeOverlapped__System_Threading_Overlapped___ptrSystem_Threading__NativeOverlapped__System_Threading_Overlapped *, 
		[global::System.Runtime.InteropServices.McgGeneratedMarshallingCode]
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "CancelIoEx")]
		public static bool CancelIoEx(
					global::System.Runtime.InteropServices.SafeHandle handle, 
					global::System.Threading.NativeOverlapped__System_Threading_Overlapped* lpOverlapped)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			handle.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::McgInterop.api_ms_win_core_io_l1_1_0_dll_PInvokes.CancelIoEx(
								handle.DangerousGetHandle(), 
								((global::System.Threading.NativeOverlapped__System_Threading_Overlapped*)lpOverlapped)
							);
			global::System.Runtime.InteropServices.DebugAnnotations.PreviousCallContainsUserCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				handle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}
	}

	public unsafe static partial class kernel32_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-processthreads-l1-1-2.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetCurrentProcessId();
	}

	public unsafe static partial class BCrypt_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptEnumAlgorithms(
					global::PInvoke.BCrypt_AlgorithmOperations__PInvoke_BCrypt dwAlgOperations, 
					int* pAlgCount, 
					global::PInvoke.BCrypt_BCRYPT_ALGORITHM_IDENTIFIER__PInvoke_BCrypt** ppAlgList, 
					global::PInvoke.BCrypt_BCryptEnumAlgorithmsFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptOpenAlgorithmProvider(
					global::System.IntPtr* phAlgorithm, 
					ushort* pszAlgId, 
					ushort* pszImplementation, 
					global::PInvoke.BCrypt_BCryptOpenAlgorithmProviderFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptCreateHash(
					global::System.IntPtr hAlgorithm, 
					global::System.IntPtr* phHash, 
					byte* pbHashObject, 
					int cbHashObject, 
					byte* pbSecret, 
					int cbSecret, 
					global::PInvoke.BCrypt_BCryptCreateHashFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptEncrypt(
					global::System.IntPtr hKey, 
					byte* pbInput, 
					int cbInput, 
					void* pPaddingInfo, 
					byte* pbIV, 
					int cbIV, 
					byte* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					global::PInvoke.BCrypt_BCryptEncryptFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptDecrypt(
					global::System.IntPtr hKey, 
					byte* pbInput, 
					int cbInput, 
					void* pPaddingInfo, 
					byte* pbIV, 
					int cbIV, 
					byte* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					global::PInvoke.BCrypt_BCryptEncryptFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptHashData(
					global::System.IntPtr hHash, 
					byte* pbInput, 
					int cbInput, 
					global::PInvoke.BCrypt_BCryptHashDataFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptFinishHash(
					global::System.IntPtr hHash, 
					byte* pbOutput, 
					int cbOutput, 
					global::PInvoke.BCrypt_BCryptFinishHashFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptSignHash(
					global::System.IntPtr hKey, 
					void* pPaddingInfo, 
					byte* pbInput, 
					int cbInput, 
					byte* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					global::PInvoke.BCrypt_BCryptSignHashFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptVerifySignature(
					global::System.IntPtr hKey, 
					void* pPaddingInfo, 
					byte* pbHash, 
					int cbHash, 
					byte* pbSignature, 
					int cbSignature, 
					global::PInvoke.BCrypt_BCryptSignHashFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptGenerateKeyPair(
					global::System.IntPtr hAlgorithm, 
					global::System.IntPtr* phKey, 
					int dwLength, 
					global::PInvoke.BCrypt_BCryptGenerateKeyPairFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptGenerateSymmetricKey(
					global::System.IntPtr hAlgorithm, 
					global::System.IntPtr* phKey, 
					byte* pbKeyObject, 
					int cbKeyObject, 
					byte* pbSecret, 
					int cbSecret, 
					global::PInvoke.BCrypt_BCryptGenerateSymmetricKeyFlags__PInvoke_BCrypt flags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptFinalizeKeyPair(
					global::System.IntPtr hKey, 
					global::PInvoke.BCrypt_BCryptFinalizeKeyPairFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptImportKey(
					global::System.IntPtr hAlgorithm, 
					global::System.IntPtr hImportKey, 
					ushort* pszBlobType, 
					global::System.IntPtr* phKey, 
					byte* pbKeyObject, 
					int cbKeyObject, 
					byte* pbInput, 
					int cbInput, 
					global::PInvoke.BCrypt_BCryptImportKeyFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptImportKeyPair(
					global::System.IntPtr hAlgorithm, 
					global::System.IntPtr hImportKey, 
					ushort* pszBlobType, 
					global::System.IntPtr* phKey, 
					byte* pbInput, 
					int cbInput, 
					global::PInvoke.BCrypt_BCryptImportKeyPairFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptExportKey(
					global::System.IntPtr hKey, 
					global::System.IntPtr hExportKey, 
					ushort* pszBlobType, 
					byte* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					global::PInvoke.BCrypt_BCryptExportKeyFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptSecretAgreement(
					global::System.IntPtr privateKey, 
					global::System.IntPtr publicKey, 
					global::System.IntPtr* secret, 
					global::PInvoke.BCrypt_BCryptSecretAgreementFlags__PInvoke_BCrypt flags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptDeriveKey(
					global::System.IntPtr sharedSecret, 
					ushort* keyDerivationFunction, 
					global::PInvoke.BCrypt_BCryptBufferDesc__PInvoke_BCrypt* kdfParameters, 
					byte* derivedKey, 
					int derivedKeySize, 
					int* resultSize, 
					global::PInvoke.BCrypt_BCryptDeriveKeyFlags__PInvoke_BCrypt flags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptSetProperty(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					byte* pbInput, 
					int cbInput, 
					global::PInvoke.BCrypt_BCryptSetPropertyFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", EntryPoint="BCryptSetProperty", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptSetProperty__0(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					ushort* pbInput, 
					int cbInput, 
					global::PInvoke.BCrypt_BCryptSetPropertyFlags__PInvoke_BCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptGetProperty(
					global::System.IntPtr hObject, 
					ushort* property, 
					byte* output, 
					int outputSize, 
					int* resultSize, 
					global::PInvoke.BCrypt_BCryptGetPropertyFlags__PInvoke_BCrypt flags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptGenRandom(
					global::System.IntPtr hAlgorithm, 
					byte* pbBuffer, 
					int cbBuffer, 
					global::PInvoke.BCrypt_BCryptGenRandomFlags__PInvoke_BCrypt flags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void BCryptFreeBuffer(void* pvBuffer);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptCloseAlgorithmProvider(
					global::System.IntPtr algorithmHandle, 
					global::PInvoke.BCrypt_BCryptCloseAlgorithmProviderFlags__PInvoke_BCrypt flags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptDestroyHash(global::System.IntPtr hHash);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptDestroyKey(global::System.IntPtr hKey);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("bcrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NTSTATUS__PInvoke_Windows_Core BCryptDestroySecret(global::System.IntPtr hSecret);
	}

	public unsafe static partial class api_ms_win_core_file_l1_2_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", EntryPoint="FindFirstFileExA", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr FindFirstFileEx(
					byte* lpFileName, 
					global::PInvoke.Kernel32_FINDEX_INFO_LEVELS__PInvoke_Kernel32 fInfoLevelId, 
					global::PInvoke.Kernel32_WIN32_FIND_DATA__PInvoke_Kernel32__Impl.UnsafeType* lpFindFileData, 
					global::PInvoke.Kernel32_FINDEX_SEARCH_OPS__PInvoke_Kernel32 fSearchOp, 
					void* lpSearchFilter, 
					global::PInvoke.Kernel32_FindFirstFileExFlags__PInvoke_Kernel32 dwAdditionalFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int ReadFile(
					global::System.IntPtr hFile, 
					void* lpBuffer, 
					int nNumberOfBytesToRead, 
					int* lpNumberOfBytesRead, 
					global::PInvoke.Kernel32_OVERLAPPED__PInvoke_Kernel32* lpOverlapped);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int WriteFile(
					global::System.IntPtr hFile, 
					void* lpBuffer, 
					int nNumberOfBytesToWrite, 
					int* lpNumberOfBytesWritten, 
					global::PInvoke.Kernel32_OVERLAPPED__PInvoke_Kernel32* lpOverlapped);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FlushFileBuffers(global::System.IntPtr hFile);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FindClose(global::System.IntPtr hFindFile);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CreateFile2(
					ushort* lpFileName, 
					int dwDesiredAccess, 
					global::System.IO.FileShare__System_IO_FileSystem_Primitives dwShareMode, 
					global::System.IO.FileMode__System_IO_FileSystem_Primitives dwCreationDisposition, 
					global::Interop_mincore_CREATEFILE2_EXTENDED_PARAMETERS__System_IO_FileSystem* parameters);
	}

	public unsafe static partial class api_ms_win_core_localization_l1_2_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-1.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage(
					global::PInvoke.Kernel32_FormatMessageFlags__PInvoke_Kernel32 dwFlags, 
					void* lpSource, 
					int dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* Arguments);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int IsValidLocaleName(ushort* lpLocaleName);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int ResolveLocaleName(
					ushort* lpNameToResolve, 
					ushort* lpLocaleName, 
					int cchLocaleName);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetCPInfoExW(
					uint CodePage, 
					uint dwFlags, 
					global::Interop_mincore_CPINFOEXW__System_Text_Encoding_CodePages* lpCPInfoEx);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-1.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__0(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-1.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__1(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-1.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__2(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-1.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__3(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);
	}

	public unsafe static partial class api_ms_win_core_processthreads_l1_1_1_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-processthreads-l1-1-2.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetCurrentThreadId();

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-processthreads-l1-1-2.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetCurrentProcessId();

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-processthreads-l1-1-2.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr GetCurrentProcess();

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-processthreads-l1-1-2.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int SuspendThread(global::System.IntPtr hThread);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-processthreads-l1-1-2.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int ResumeThread(global::System.IntPtr hThread);
	}

	public unsafe static partial class api_ms_win_core_io_l1_1_1_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-io-l1-1-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CancelIoEx(
					global::System.IntPtr hFile, 
					global::PInvoke.Kernel32_OVERLAPPED__PInvoke_Kernel32* lpOverlapped);
	}

	public unsafe static partial class api_ms_win_core_synch_l1_2_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-synch-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.Kernel32_WaitForSingleObjectResult__PInvoke_Kernel32 WaitForSingleObject(
					global::System.IntPtr hHandle, 
					int dwMilliseconds);
	}

	public unsafe static partial class api_ms_win_core_handle_l1_1_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-handle-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CloseHandle(global::System.IntPtr hObject);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-handle-l1-1-0.dll", EntryPoint="CloseHandle", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CloseHandle__0(global::System.IntPtr handle);
	}

	public unsafe static partial class NCrypt_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptOpenStorageProvider(
					global::System.IntPtr* phProvider, 
					ushort* pszProviderName, 
					global::PInvoke.NCrypt_NCryptOpenStorageProviderFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptCreatePersistedKey(
					global::System.IntPtr hProvider, 
					global::System.IntPtr* phKey, 
					ushort* pszAlgId, 
					ushort* pszKeyName, 
					global::PInvoke.NCrypt_LegacyKeySpec__PInvoke_NCrypt dwLegacyKeySpec, 
					global::PInvoke.NCrypt_NCryptCreatePersistedKeyFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptOpenKey(
					global::System.IntPtr hProvider, 
					global::System.IntPtr* phKey, 
					ushort* pszKeyName, 
					global::PInvoke.NCrypt_LegacyKeySpec__PInvoke_NCrypt dwLegacyKeySpec, 
					global::PInvoke.NCrypt_NCryptOpenKeyFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptDeleteKey(
					global::System.IntPtr hKey, 
					global::PInvoke.NCrypt_NCryptDeleteKeyFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptSecretAgreement(
					global::System.IntPtr hPrivKey, 
					global::System.IntPtr hPubKey, 
					global::System.IntPtr* phSecret, 
					global::PInvoke.NCrypt_NCryptSecretAgreementFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptKeyDerivation(
					global::System.IntPtr hKey, 
					global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt* pParameterList, 
					byte* pbDerivedKey, 
					int cbDerivedKey, 
					int* pcbResult, 
					global::PInvoke.NCrypt_NCryptKeyDerivationFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptDeriveKey(
					global::System.IntPtr hSharedSecret, 
					ushort* pwszKDF, 
					global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt* pParameterList, 
					byte* pbDerivedKey, 
					int cbDerivedKey, 
					int* pcbResult, 
					global::PInvoke.NCrypt_NCryptDeriveKeyFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptEnumAlgorithms(
					global::System.IntPtr hProvider, 
					global::PInvoke.NCrypt_AlgorithmOperations__PInvoke_NCrypt dwAlgOperations, 
					int* pdwAlgCount, 
					global::PInvoke.NCrypt_NCryptAlgorithmName__PInvoke_NCrypt** ppAlgList, 
					global::PInvoke.NCrypt_NCryptEnumAlgorithmsFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptEnumKeys(
					global::System.IntPtr hProvider, 
					ushort* pszScope, 
					global::PInvoke.NCrypt_NCryptKeyName__PInvoke_NCrypt** ppKeyName, 
					void** ppEnumState, 
					global::PInvoke.NCrypt_NCryptEnumKeysFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptIsAlgSupported(
					global::System.IntPtr hProvider, 
					ushort* pszAlgId, 
					global::PInvoke.NCrypt_NCryptIsAlgSupportedFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptFinalizeKey(
					global::System.IntPtr hKey, 
					global::PInvoke.NCrypt_NCryptFinalizeKeyFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptExportKey(
					global::System.IntPtr hKey, 
					global::System.IntPtr hExportKey, 
					ushort* pszBlobType, 
					global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt* pParameterList, 
					byte* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					global::PInvoke.NCrypt_NCryptExportKeyFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptImportKey(
					global::System.IntPtr hProvider, 
					global::System.IntPtr hImportKey, 
					ushort* pszBlobType, 
					global::PInvoke.NCrypt_NCryptBufferDesc__PInvoke_NCrypt* pParameterList, 
					global::System.IntPtr* phKey, 
					byte* pbData, 
					int cbData, 
					global::PInvoke.NCrypt_NCryptExportKeyFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptGetProperty(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					byte* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					global::PInvoke.NCrypt_NCryptGetPropertyFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptSetProperty(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					byte* pbInput, 
					int cbInput, 
					global::PInvoke.NCrypt_NCryptSetPropertyFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", EntryPoint="NCryptSetProperty", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptSetProperty__0(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					ushort* pbInput, 
					int cbInput, 
					global::PInvoke.NCrypt_NCryptSetPropertyFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptEncrypt(
					global::System.IntPtr hKey, 
					byte* pbInput, 
					int cbInput, 
					void* pPaddingInfo, 
					byte* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					global::PInvoke.NCrypt_NCryptEncryptFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptDecrypt(
					global::System.IntPtr hKey, 
					byte* pbInput, 
					int cbInput, 
					void* pPaddingInfo, 
					byte* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					global::PInvoke.NCrypt_NCryptEncryptFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptSignHash(
					global::System.IntPtr hKey, 
					void* pPaddingInfo, 
					byte* pbHashValue, 
					int cbHashValue, 
					byte* pbSignature, 
					int cbSignature, 
					int* pcbResult, 
					global::PInvoke.NCrypt_NCryptSignHashFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptVerifySignature(
					global::System.IntPtr hKey, 
					void* pPaddingInfo, 
					byte* pbHashValue, 
					int cbHashValue, 
					byte* pbSignature, 
					int cbSignature, 
					global::PInvoke.NCrypt_NCryptSignHashFlags__PInvoke_NCrypt dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptFreeBuffer(void* pvInput);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::PInvoke.NCrypt_SECURITY_STATUS__PInvoke_NCrypt NCryptFreeObject(global::System.IntPtr hObject);
	}

	public unsafe static partial class _MRT__PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void RhWaitForPendingFinalizers(int allowReentrantWait);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int RhCompatibleReentrantWaitAny(
					int alertable, 
					int timeout, 
					int count, 
					global::System.IntPtr* handles);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void _ecvt_s(
					byte* buffer, 
					int sizeInBytes, 
					double value, 
					int count, 
					int* dec, 
					int* sign);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void memmove(
					byte* dmem, 
					byte* smem, 
					uint size);
	}

	public unsafe static partial class __PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("*", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void CallingConventionConverter_GetStubs(
					global::System.IntPtr* returnVoidStub, 
					global::System.IntPtr* returnIntegerStub, 
					global::System.IntPtr* commonStub, 
					global::System.IntPtr* returnFloatingPointReturn4Thunk, 
					global::System.IntPtr* returnFloatingPointReturn8Thunk);
	}

	public unsafe static partial class api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-errorhandling-l1-1-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetLastError();
	}

	public unsafe static partial class api_ms_win_core_winrt_l1_1_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int RoInitialize(uint initType);
	}

	public unsafe static partial class ws2_32_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#6", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives getsockname(
					global::System.IntPtr socketHandle, 
					byte* socketAddress, 
					int* socketAddressSize);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#7", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives getsockopt(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					int* optionValue, 
					int* optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSARecv(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets* buffer, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets* socketFlags, 
					global::System.IntPtr overlapped, 
					global::System.IntPtr completionRoutine);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="WSARecv", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSARecv__0(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets* buffers, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets* socketFlags, 
					global::System.IntPtr overlapped, 
					global::System.IntPtr completionRoutine);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSASend(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets* buffer, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.IntPtr overlapped, 
					global::System.IntPtr completionRoutine);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="WSASend", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSASend__0(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets* buffersArray, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.IntPtr overlapped, 
					global::System.IntPtr completionRoutine);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#5", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives getpeername(
					global::System.IntPtr socketHandle, 
					byte* socketAddress, 
					int* socketAddressSize);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#22", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives shutdown(
					global::System.IntPtr socketHandle, 
					int how);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSARecvFrom(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets* buffer, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets* socketFlags, 
					global::System.IntPtr socketAddressPointer, 
					global::System.IntPtr socketAddressSizePointer, 
					global::System.IntPtr overlapped, 
					global::System.IntPtr completionRoutine);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="WSARecvFrom", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSARecvFrom__0(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets* buffers, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets* socketFlags, 
					global::System.IntPtr socketAddressPointer, 
					global::System.IntPtr socketAddressSizePointer, 
					global::System.IntPtr overlapped, 
					global::System.IntPtr completionRoutine);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSASendTo(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets* buffer, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.IntPtr socketAddress, 
					int socketAddressSize, 
					global::System.IntPtr overlapped, 
					global::System.IntPtr completionRoutine);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="WSASendTo", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSASendTo__0(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets* buffersArray, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.IntPtr socketAddress, 
					int socketAddressSize, 
					global::System.IntPtr overlapped, 
					global::System.IntPtr completionRoutine);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#20", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int sendto(
					global::System.IntPtr socketHandle, 
					byte* pinnedBuffer, 
					int len, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					byte* socketAddress, 
					int socketAddressSize);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#13", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives listen(
					global::System.IntPtr socketHandle, 
					int backlog);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#16", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int recv(
					global::System.IntPtr socketHandle, 
					byte* pinnedBuffer, 
					int len, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#19", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int send(
					global::System.IntPtr socketHandle, 
					byte* pinnedBuffer, 
					int len, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="WSASend", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSASend_Blocking(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.WSABuffer__System_Net_Sockets* buffersArray, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System.IntPtr overlapped, 
					global::System.IntPtr completionRoutine);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#115", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSAStartup(
					short wVersionRequested, 
					global::Interop_Winsock_WSAData__System_Net_NameResolution__Impl.UnsafeType* lpWSAData);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#18", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int select(
					int ignoredParameter, 
					global::System.IntPtr* readfds, 
					global::System.IntPtr* writefds, 
					global::System.IntPtr* exceptfds, 
					global::Interop_Winsock_TimeValue__System_Net_Sockets* timeout);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#18", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int select__0(
					int ignoredParameter, 
					global::System.IntPtr* readfds, 
					global::System.IntPtr* writefds, 
					global::System.IntPtr* exceptfds, 
					global::System.IntPtr nullTimeout);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#10", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives ioctlsocket(
					global::System.IntPtr socketHandle, 
					int cmd, 
					int* argp);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#2", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives bind(
					global::System.IntPtr socketHandle, 
					byte* socketAddress, 
					int socketAddressSize);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#21", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					int* optionValue, 
					int optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#7", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives getsockopt__0(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::Interop_Winsock_Linger__System_Net_Sockets* optionValue, 
					int* optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#7", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives getsockopt__1(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::Interop_Winsock_IPMulticastRequest__System_Net_Sockets* optionValue, 
					int* optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#7", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives getsockopt__2(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType* optionValue, 
					int* optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSAConnect(
					global::System.IntPtr socketHandle, 
					byte* socketAddress, 
					int socketAddressSize, 
					global::System.IntPtr inBuffer, 
					global::System.IntPtr outBuffer, 
					global::System.IntPtr sQOS, 
					global::System.IntPtr gQOS);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#21", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__0(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::Interop_Winsock_Linger__System_Net_Sockets* linger, 
					int optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#21", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__1(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::Interop_Winsock_IPMulticastRequest__System_Net_Sockets* mreq, 
					int optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#21", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__2(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType* mreq, 
					int optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int WSAGetOverlappedResult(
					global::System.IntPtr socketHandle, 
					global::System.IntPtr overlapped, 
					uint* bytesTransferred, 
					int wait, 
					global::System.Net.Sockets.SocketFlags__System_Net_Sockets* socketFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr WSASocketW(
					global::System.Net.Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System.Net.Sockets.SocketType__System_Net_Sockets socketType, 
					global::System.Net.Sockets.ProtocolType__System_Net_Sockets protocolType, 
					global::System.IntPtr protocolInfo, 
					uint group, 
					global::Interop_Winsock_SocketConstructorFlags__System_Net_Sockets flags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#1", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr accept(
					global::System.IntPtr socketHandle, 
					byte* socketAddress, 
					int* socketAddressSize);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#57", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives gethostname(
					byte* hostName, 
					int bufferLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="WSASocketW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr WSASocketW__0(
					global::System.Net.Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System.Net.Sockets.SocketType__System_Net_Sockets socketType, 
					int protocolType, 
					global::System.IntPtr protocolInfo, 
					int group, 
					int flags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#3", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives closesocket(global::System.IntPtr socketHandle);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#21", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__3(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::System.IntPtr* pointer, 
					int optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#21", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__4(
					global::System.IntPtr socketHandle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					byte* optionValue, 
					int optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#10", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives ioctlsocket__0(
					global::System.IntPtr handle, 
					int cmd, 
					int* argp);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSAEventSelect(
					global::System.IntPtr handle, 
					global::System.IntPtr Event, 
					global::Interop_Winsock_AsyncEventBits__System_Net_Sockets NetworkEvents);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#21", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives setsockopt__5(
					global::System.IntPtr handle, 
					global::System.Net.Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System.Net.Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::Interop_Winsock_Linger__System_Net_Sockets* linger, 
					int optionLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives WSAIoctl(
					global::System.IntPtr socketHandle, 
					int ioControlCode, 
					global::System.Guid* guid, 
					int guidSize, 
					global::System.IntPtr* funcPtr, 
					int funcPtrSize, 
					int* bytesTransferred, 
					global::System.IntPtr shouldBeNull, 
					global::System.IntPtr shouldBeNull2);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives GetNameInfoW(
					byte* sa, 
					int salen, 
					ushort* host, 
					int hostlen, 
					ushort* serv, 
					int servlen, 
					int flags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#51", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr gethostbyaddr(
					int* addr, 
					int len, 
					global::System.Net.Sockets.ProtocolFamily__System_Net_NameResolution type);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#52", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr gethostbyname(byte* host);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetAddrInfoW(
					ushort* nodename, 
					ushort* servicename, 
					global::System.Net.Sockets.AddressInfo__System_Net_NameResolution* hints, 
					global::System.IntPtr* handle);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="WSASocketW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr WSASocketW__1(
					global::System.Net.Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System.Net.Internals.SocketType__System_Net_NameResolution socketType, 
					int protocolType, 
					global::System.IntPtr protocolInfo, 
					int group, 
					int flags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="#3", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.Net.Sockets.SocketError__System_Net_Primitives closesocket__0(global::System.IntPtr socketHandle);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void freeaddrinfo(global::System.IntPtr info);
	}

	public unsafe static partial class ntdll_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ntdll.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint RtlIpv6StringToAddressExW(
					ushort* s, 
					byte* address, 
					uint* scopeId, 
					ushort* port);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ntdll.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint RtlIpv4StringToAddressExW(
					ushort* s, 
					int strict, 
					byte* address, 
					ushort* port);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ntdll.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint RtlIpv6AddressToStringExW(
					byte* address, 
					uint scopeId, 
					ushort port, 
					ushort* addressString, 
					uint* addressStringLength);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ntdll.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint RtlIpv4AddressToStringExW(
					byte* address, 
					ushort port, 
					ushort* addressString, 
					uint* addressStringLength);
	}

	public unsafe static partial class api_ms_win_core_winrt_robuffer_l1_1_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-robuffer-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.StdCall)]
		public extern static int RoGetBufferMarshaler(global::System.Runtime.InteropServices.IMarshal__System_Runtime_WindowsRuntime__Impl.Vtbl*** bufferMarshalerPtr);
	}

	public unsafe static partial class crypt32_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertDuplicateCertificateContext(global::System.IntPtr pCertContext);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetCertificateContextProperty(
					global::System.IntPtr pCertContext, 
					global::Internal.Cryptography.Pal.Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					global::Internal.Cryptography.Pal.Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pvData, 
					int* pcbData);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertGetCertificateContextProperty", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetCertificateContextProperty__0(
					global::System.IntPtr pCertContext, 
					global::Internal.Cryptography.Pal.Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					byte* pvData, 
					int* pcbData);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertDuplicateCertificateContext", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertDuplicateCertificateContextWithKeyContainerDeletion(global::System.IntPtr pCertContext);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptQueryObject(
					global::Internal.Cryptography.Pal.Native.CertQueryObjectType__System_Security_Cryptography_X509Certificates dwObjectType, 
					void* pvObject, 
					global::Internal.Cryptography.Pal.Native.ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedContentTypeFlags, 
					global::Internal.Cryptography.Pal.Native.ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedFormatTypeFlags, 
					int dwFlags, 
					global::Internal.Cryptography.Pal.Native.CertEncodingType__System_Security_Cryptography_X509Certificates* pdwMsgAndCertEncodingType, 
					global::Internal.Cryptography.Pal.Native.ContentType__System_Security_Cryptography_X509Certificates* pdwContentType, 
					global::Internal.Cryptography.Pal.Native.FormatType__System_Security_Cryptography_X509Certificates* pdwFormatType, 
					global::System.IntPtr* phCertStore, 
					global::System.IntPtr* phMsg, 
					global::System.IntPtr* ppvContext);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertFreeCertificateContext(global::System.IntPtr pCertContext);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptMsgGetParam(
					global::System.IntPtr hCryptMsg, 
					global::Internal.Cryptography.Pal.Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					int* pvData, 
					int* pcbData);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptMsgGetParam", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptMsgGetParam__0(
					global::System.IntPtr hCryptMsg, 
					global::Internal.Cryptography.Pal.Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					byte* pvData, 
					int* pcbData);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr PFXImportCertStore(
					global::Internal.Cryptography.Pal.Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pPFX, 
					ushort* szPassword, 
					global::Internal.Cryptography.Pal.Native.PfxCertStoreFlags__System_Security_Cryptography_X509Certificates dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertGetNameStringW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetNameString(
					global::System.IntPtr pCertContext, 
					global::Internal.Cryptography.Pal.Native.CertNameType__System_Security_Cryptography_X509Certificates dwType, 
					global::Internal.Cryptography.Pal.Native.CertNameFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::Internal.Cryptography.Pal.Native.CertNameStringType__System_Security_Cryptography_X509Certificates* pvTypePara, 
					ushort* pszNameString, 
					int cchNameString);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertCloseStore(
					global::System.IntPtr hCertStore, 
					int dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptMsgClose(global::System.IntPtr hCryptMsg);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertFindCertificateInStore(
					global::System.IntPtr hCertStore, 
					global::Internal.Cryptography.Pal.Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal.Cryptography.Pal.Native.CertFindFlags__System_Security_Cryptography_X509Certificates dwFindFlags, 
					global::Internal.Cryptography.Pal.Native.CertFindType__System_Security_Cryptography_X509Certificates dwFindType, 
					void* pvFindPara, 
					global::Internal.Cryptography.Pal.Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertEnumCertificatesInStore(
					global::System.IntPtr hCertStore, 
					global::Internal.Cryptography.Pal.Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext);
	}

	public unsafe static partial class api_ms_win_core_threadpool_l1_2_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-threadpool-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CreateThreadpoolIo(
					global::System.IntPtr fl, 
					void* pfnio, 
					global::System.IntPtr context, 
					global::System.IntPtr pcbe);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-threadpool-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void StartThreadpoolIo(global::System.IntPtr pio);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-threadpool-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void CancelThreadpoolIo(global::System.IntPtr pio);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-threadpool-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void CloseThreadpoolIo(global::System.IntPtr pio);
	}

	public unsafe static partial class api_ms_win_core_com_l1_1_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-com-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CoCreateInstance(
					byte* rclsid, 
					global::System.IntPtr pUnkOuter, 
					int dwClsContext, 
					byte* riid, 
					global::System.IntPtr* ppv);
	}

	public unsafe static partial class OleAut32_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("oleaut32.dll", EntryPoint="#6", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void SysFreeString(global::System.IntPtr bstr);
	}

	public unsafe static partial class ncrypt_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenKey(
					global::System.IntPtr hProvider, 
					global::System.IntPtr* phKey, 
					ushort* pszKeyName, 
					int dwLegacyKeySpec, 
					global::System.Security.Cryptography.CngKeyOpenOptions__System_Security_Cryptography_Cng dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptDeleteKey(
					global::System.IntPtr hKey, 
					int dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenStorageProvider(
					global::System.IntPtr* phProvider, 
					ushort* pszProviderName, 
					int dwFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptFreeObject(global::System.IntPtr hObject);
	}

	public unsafe static partial class api_ms_win_core_file_l1_1_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetFileType(global::System.IntPtr hFile);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int SetFilePointerEx(
					global::System.IntPtr hFile, 
					long liDistanceToMove, 
					long* lpNewFilePointer, 
					uint dwMoveMethod);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int SetEndOfFile(global::System.IntPtr hFile);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", EntryPoint="GetFileAttributesExW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetFileAttributesExPrivate(
					ushort* name, 
					global::Interop_mincore_GET_FILEEX_INFO_LEVELS__System_IO_FileSystem fileInfoLevel, 
					global::Interop_mincore_WIN32_FILE_ATTRIBUTE_DATA__System_IO_FileSystem* lpFileInformation);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", EntryPoint="FindFirstFileExW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr FindFirstFileExPrivate(
					ushort* lpFileName, 
					global::Interop_mincore_FINDEX_INFO_LEVELS__System_IO_FileSystem fInfoLevelId, 
					global::Interop_mincore_WIN32_FIND_DATA__System_IO_FileSystem__Impl.UnsafeType* lpFindFileData, 
					global::Interop_mincore_FINDEX_SEARCH_OPS__System_IO_FileSystem fSearchOp, 
					global::System.IntPtr lpSearchFilter, 
					int dwAdditionalFlags);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int ReadFile(
					global::System.IntPtr handle, 
					byte* bytes, 
					int numBytesToRead, 
					global::System.IntPtr numBytesRead_mustBeZero, 
					global::System.Threading.NativeOverlapped__System_Threading_Overlapped* overlapped);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", EntryPoint="ReadFile", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int ReadFile__0(
					global::System.IntPtr handle, 
					byte* bytes, 
					int numBytesToRead, 
					int* numBytesRead, 
					global::System.IntPtr mustBeZero);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int WriteFile(
					global::System.IntPtr handle, 
					byte* bytes, 
					int numBytesToWrite, 
					global::System.IntPtr numBytesWritten_mustBeZero, 
					global::System.Threading.NativeOverlapped__System_Threading_Overlapped* lpOverlapped);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", EntryPoint="WriteFile", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int WriteFile__0(
					global::System.IntPtr handle, 
					byte* bytes, 
					int numBytesToWrite, 
					int* numBytesWritten, 
					global::System.IntPtr mustBeZero);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FindClose(global::System.IntPtr hFindFile);

		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l1-2-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FlushFileBuffers(global::System.IntPtr hHandle);
	}

	public unsafe static partial class api_ms_win_core_file_l2_1_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-file-l2-1-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetFileInformationByHandleEx(
					global::System.IntPtr hFile, 
					global::Interop_mincore_FILE_INFO_BY_HANDLE_CLASS__System_IO_FileSystem FileInformationClass, 
					global::Interop_mincore_FILE_STANDARD_INFO__System_IO_FileSystem* lpFileInformation, 
					uint dwBufferSize);
	}

	public unsafe static partial class api_ms_win_core_io_l1_1_0_dll_PInvokes
	{
		[global::McgInterop.McgGeneratedNativeCallCode]
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-io-l1-1-1.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CancelIoEx(
					global::System.IntPtr handle, 
					global::System.Threading.NativeOverlapped__System_Threading_Overlapped* lpOverlapped);
	}
}

